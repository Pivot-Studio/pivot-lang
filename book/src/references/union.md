# Pivot Lang的Union语法

在Pivot Lang中，Union类型允许你将多种不同的类型组合在一起。你可以定义一个Union类型，它可以包含任何你需要的类型。以下是一些Union类型的定义：

```pivot
type A<T> = f32 | T;
type B<T> = i32 | A<T>;
type D = *i32 | f64;
```

在上述代码中，`A`是一个泛型Union类型，它可以是`f32`或者任何其他类型`T`。`B`也是一个泛型Union类型，它可以是`i32`或者类型`A`。`D`是一个Union类型，它可以是`*i32`或者`f64`。
你可以使用Union类型来定义变量，如下所示：

```pivot
let c: A<i128> = a;
let aa: B<i128> = d;
let ff: D = &gg;
```

你也可以使用Union类型在函数中作为返回值，如下所示：

```pivot
fn test_ret_union() Option<i64> {
    return 101;
}
```

你还可以在Union类型上定义方法，如下所示：

```pivot
impl<T> A<T> {
    fn name() void {
        let f = (*self) as f32!;
        f = 100.0;
        return;
    }
}
```

此外，你还可以在函数中使用Union类型作为参数，如下所示：

```pivot
fn generic<R>(a: Option<R>) void {
    let c = a as R!;
    a = c;
    return;
}
```

## Union与其子类型转化

### 隐式类型转化

隐式转化主要出现在赋值操作中。例如：

```rust
let c: A<i128> = a;
```

在这行代码中，变量 `a` 的类型是 `i128`，在赋值给 `c` 时，它被隐式转化为 `A<i128>` 类型。这是因为 `A<i128>` 类型包含了 `i128` 类型，所以 `i128` 类型可以被隐式转化为 `A<i128>` 类型。

### 显式类型转化

显式类型转化主要通过 `as` 关键字进行。例如：

```rust
let h = c as i128?;
```

在这行代码中，变量 `c` 的类型是 `A<i128>`，使用 `as` 关键字将其显式转化为 `Option<i128>` 类型。因为 `A<i128>` 类型包含了 `i128` 类型，但是她不一定是 `i128` 类型，所以 `A<i128>` 类型可以被安全的显式转化为 `Option<i128>` 类型。

### 强制类型转化

强制类型转化通过 `as ... !` 符号进行。例如：

```rust
let i = c!;
```

在这行代码中，变量 `c` 的类型是 `A<i128>`，使用 `!` 符号将其强制转化为 `i128` 类型。这是因为 `A<i128>` 类型包含了 `i128` 类型，所以 `A<i128>` 类型可以被强制转化为 `i128` 类型。
