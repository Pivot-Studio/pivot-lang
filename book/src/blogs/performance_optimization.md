# Performance Optimization

## Introduction

Performance matters. Although speed may not be the most important factor in some languages, it is a universal truth that nearly all languages can benefit from higher performance.

Higher performance can lead to better user experience, lower server costs, and more efficient use of resources. It can also give your application a competitive edge.

However, achieving high performance is not easy. It requires a deep understanding of the language, the runtime, and the hardware. It also requires a lot of time and effort. In this blog post, we will discuss some of the techniques that can be used to optimize the performance of a programming language and how
we applied them to Pivot Lang.

## Main Factors Affecting Performance

### 1. LLVM Optimization

LLVM is a powerful compiler infrastructure that can be used to generate highly optimized machine code. However, it can not do much if the ir code generated by the frontend is not following the best practices.
It is not enough to just generate correct code, you need to add various metadata to help LLVM optimize the code. You can find more information about this in the [LLVM documentation](https://llvm.org/docs/Frontend/PerformanceTips.html).

### 2. Garbage Collection

If you are using a garbage collector, it is important to make sure that it intergrates well with the rest of the system. Even best garbage collector can cause performance issues if it is not used correctly.

Garbage collectors have two basic types: conservative and precise. There's not much we can do
while using thirdparty fully conservative garbage collectors (like bdwgc), but with custom precise garbage collectors, we can
make a large difference by changing the machanism of stack scanning, adjusting collect frequency etc.

#### Stack Scanning

There are many different ways to scan the stack, if you are not using llvm's gc api, you can scan the stack
conservatively, very much like bdwgc does, it's fast enough in most cases. Otherwise, you can choose between
llvm's `gc.root` and `gc.statepoint` to perform precise stack scanning.

Even with same llvm scanning method, you can still make a difference by changing the way you
crawl the stack, for example, you can use libunwind walk the whole stack, or you can use llvm's
inline assembly to get the stack pointer and walk the stack manually by the help of `stackmap`.
Those machanisms are discussed in detail in the [LLVM and GC](https://yuchenx.pages.dev/blog/llvm/llvm-and-gc/) blog post.


