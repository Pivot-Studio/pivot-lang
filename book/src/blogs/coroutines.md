# 开发协程的一些想法


## 1. 为什么要开发协程

协程是一种轻量级的线程，它可以在一个线程中实现多个任务的切换，从而实现并发。
如果不提供协程，那么用户得手动使用多线程，调用同步io的api。这对性能很不友好。

同时，协程应该尽早的引入。因为无栈协程对编程接口有影响。如果在借口定型后才增加无栈
协程，那么就需要对接口进行修改，这对用户来说是不友好的。

## 2. 无栈协程？

无栈协程主要是[@CJiW]在进行开发。无栈协程的主要优势是性能好一些，
他不需要分配很多栈空间。缺点是它一般需要引入async/await语法，这对用户来说是不友好的。

[@CJiW]:https://github.com/CjiW

一开始我们想采用无栈协程，主要是我对无栈协程的实现更有经验，并且我对有栈协程和gc的互动
有点担心。

## 3. 有栈协程？

有栈协程的优势是他不需要引入新的语法，我们初期并没有考虑有栈协程，因为我对一些知识的理解有误，错误的认为
有栈协程需要gc进行改造才能支持。但是最近进行了一些简单的实验之后发现事实并非如此。事实上我们的系统已经
可以直接接入一些第三方的有栈协程库，比如[may]，并进行使用。


不过may相关的io部分还是需要进行一些修改，因为ffi调用的内存管理会很麻烦。所以我目前的思考是使用[context.rs]来
实现有栈协程，io在pl侧进行封装，使用[@CjiW]实现的Reactor进行调度。`context.rs`中代码可能得进行一些修改，方便
与GC进行交互。


### 方案

context.rs中的一个context对应我们一个协程，每个线程存一个threadlocal的context，对应调度器协程，每次
进入io调用的时候resume到调度器协程。


[may]:https://github.com/Xudong-Huang/may
[context.rs]:https://github.com/zonyitoo/context-rs


### 其他相关库

[libfringe](https://github.com/edef1c/libfringe)