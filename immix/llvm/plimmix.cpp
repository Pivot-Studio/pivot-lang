// lib/MyGC/MyGC.cpp - Example LLVM GC plugin

// #include "llvm/CodeGen/GCStrategy.h"
#include "llvm/IR/GCStrategy.h"
#include "llvm/CodeGen/GCMetadata.h"
#include "llvm/Support/Compiler.h"
#include "plimmixprinter.cpp"
#include "llvm/IR/LegacyPassManager.h"
// #include "llvm/IR/BuiltinGCs.h"
// #include "gcpass.cpp"
#include "llvm/Transforms/Scalar.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/Support/Casting.h"
using namespace llvm;

namespace {
  class LLVM_LIBRARY_VISIBILITY PLImmixGC : public GCStrategy {
  public:
    PLImmixGC() {
        UseStatepoints = true;
    }
  // Optional<bool> isGCManagedPointer(const Type *Ty) const override {
  //   // Method is only valid on pointer typed values.
  //   const PointerType *PT = cast<PointerType>(Ty);
  //   // For the sake of this example GC, we arbitrarily pick addrspace(1) as our
  //   // GC managed heap.  We know that a pointer into this heap needs to be
  //   // updated and that no other pointer does.  Note that addrspace(1) is used
  //   // only as an example, it has no special meaning, and is not reserved for
  //   // GC usage.
  //   return true;
  // }
  };

  GCRegistry::Add<PLImmixGC>
  X("plimmix", "pivot-lang immix garbage collector.");
}


extern "C" void LLVMAddRewriteStatepointsForGCPass(LLVMPassManagerRef PM) {
  unwrap(PM)->add(createRewriteStatepointsForGCLegacyPass());
}


/// A GCStrategy which serves as an example for the usage of a statepoint based
/// lowering strategy.  This GCStrategy is intended to suitable as a default
/// implementation usable with any collector which can consume the standard
/// stackmap format generated by statepoints, uses the default addrespace to
/// distinguish between gc managed and non-gc managed pointers, and has
/// reasonable relocation semantics.
class StatepointGC : public GCStrategy {
public:
  StatepointGC() {
    UseStatepoints = true;
    // These options are all gc.root specific, we specify them so that the
    // gc.root lowering code doesn't run.
    NeededSafePoints = false;
    UsesMetadata = false;
  }

  Optional<bool> isGCManagedPointer(const Type *Ty) const override {
    // Method is only valid on pointer typed values.
    const PointerType *PT = cast<PointerType>(Ty);
    // For the sake of this example GC, we arbitrarily pick addrspace(1) as our
    // GC managed heap.  We know that a pointer into this heap needs to be
    // updated and that no other pointer does.  Note that addrspace(1) is used
    // only as an example, it has no special meaning, and is not reserved for
    // GC usage.
    return (1 == PT->getAddressSpace());
  }
};
static GCRegistry::Add<StatepointGC> D("statepoint-example",
                                       "an example strategy for statepoint");

extern "C" void LLVMLinkPLImmixGC() {
}