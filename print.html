<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pivot Lang</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial/basicproject.html"><strong aria-hidden="true">2.2.</strong> Basic Project</a></li><li class="chapter-item expanded "><a href="tutorial/vscsupport.html"><strong aria-hidden="true">2.3.</strong> VSC Support</a></li></ol></li><li class="chapter-item expanded "><a href="references/index.html"><strong aria-hidden="true">3.</strong> References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references/module.html"><strong aria-hidden="true">3.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="references/method.html"><strong aria-hidden="true">3.2.</strong> Method</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">How the project works internally</li><li class="chapter-item expanded "><a href="compiler/index.html"><strong aria-hidden="true">4.</strong> Compiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compiler/parser.html"><strong aria-hidden="true">4.1.</strong> Parser</a></li><li class="chapter-item expanded "><a href="compiler/ast.html"><strong aria-hidden="true">4.2.</strong> AST</a></li></ol></li><li class="chapter-item expanded "><a href="lsp/index.html"><strong aria-hidden="true">5.</strong> Language Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lsp/design.html"><strong aria-hidden="true">5.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="lsp/diagnostic.html"><strong aria-hidden="true">5.2.</strong> Diagnostic</a></li></ol></li><li class="chapter-item expanded "><a href="systemlib/index.html"><strong aria-hidden="true">6.</strong> System library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="systemlib/vm.html"><strong aria-hidden="true">6.1.</strong> vm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="systemlib/gc.html"><strong aria-hidden="true">6.1.1.</strong> gc</a></li></ol></li><li class="chapter-item expanded "><a href="systemlib/planglib.html"><strong aria-hidden="true">6.2.</strong> planglib</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">CONTRIBUTING</li><li class="chapter-item expanded "><a href="CONTRIBUTING-CN.html"><strong aria-hidden="true">7.</strong> Contributing</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Pivot Lang</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/Pivot-Studio/pivot-lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pivot-lang"><a class="header" href="#pivot-lang">Pivot-lang</a></h1>
<p><a href="https://codecov.io/gh/Pivot-Studio/pivot-lang"><img src="https://codecov.io/gh/Pivot-Studio/pivot-lang/branch/master/graph/badge.svg?token=CA17PWK0EG" alt="codecov" /></a> 
<a href="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/release.yml"><img src="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/release.yml/badge.svg" alt="release" /></a>
<a href="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/test.yml"><img src="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/test.yml/badge.svg" alt="test" /></a>
<a href="https://drone.pivotstudio.cn/Pivot-Studio/pivot-lang"><img src="https://drone.pivotstudio.cn/api/badges/Pivot-Studio/pivot-lang/status.svg?ref=refs/heads/gh-pages" alt="docs" /></a></p>
<p><img src="https://codecov.io/gh/Pivot-Studio/pivot-lang/branch/master/graphs/sunburst.svg?token=CA17PWK0EG" alt="codecov" /></p>
<p>此项目目前处于早期开发阶段，不建议用于生产环境。<br />
<a href="https://github.com/Pivot-Studio/pivot-lang">项目地址</a></p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>见<a href="https://lang.pivotstudio.cn/tutorial/installation.html">此处</a></p>
<h2 id="文档地址"><a class="header" href="#文档地址">文档地址</a></h2>
<p>https://lang.pivotstudio.cn</p>
<h2 id="contributing"><a class="header" href="#contributing">CONTRIBUTING</a></h2>
<p><a href="../../CONTRIBUTING.html">CONTRIBUTING</a><br />
中文见<a href="https://lang.pivotstudio.cn/CONTRIBUTING-CN.html">此处</a><br />
欢迎加入<a href="https://jq.qq.com/?_wv=1027&amp;k=I5vdShVl">社区群</a></p>
<h2 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h2>
<ul>
<li><a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-14.0.6">llvm-14</a></li>
<li><a href="https://www.rust-lang.org/">rust</a></li>
</ul>
<p><strong>重要</strong>：如果你想参与开发，请先在项目目录<code>make vm install</code>，然后根据自己是linux还是mac运行<code>make devlinux</code>或者<code>make devmac</code></p>
<h2 id="特点"><a class="header" href="#特点">特点</a></h2>
<ul>
<li>同时支持aot和jit两种模式</li>
<li>极其方便的rust互操作</li>
<li>支持debug</li>
<li>支持lsp，自带vsc插件，能替佛那个优秀的代码支持</li>
</ul>
<h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<ul>
<li><a href="../../vm">vm</a> 包含rumtime</li>
<li><a href="../../src">src</a> 编译器源码所在</li>
<li><a href="../../internal_macro">internal_macro</a> 内部过程宏</li>
</ul>
<h2 id="grammar"><a class="header" href="#grammar">grammar</a></h2>
<pre><code class="language-ebnf">add_exp = 
    | mul_exp (&quot;+&quot; | &quot;-&quot; add_exp)?
    ;

mul_exp = 
    | unary_exp (&quot;*&quot;｜&quot;/&quot; mul_exp)?
    ;

unary_exp =
    | pointer_exp
    | (&quot;-&quot; | &quot;!&quot;) pointer_exp
    ;


pointer_exp = (&quot;&amp;&quot;|&quot;*&quot;)* complex_exp;

complex_exp = primary_exp (take_exp_op|array_element_op|call_function_op)*;

take_exp_op = (&quot;.&quot; identifier) ;

array_element_op = ('[' logic_exp ']') ;

call_function_op = (&quot;(&quot; (logic_exp (&quot;,&quot;logic_exp)*)? &quot;)&quot;) ;

primary_exp =
    | number
    | bool_const
    | parantheses_exp
    | extern_identifier
    | struct_init_exp
    | string_literal
    ;

parantheses_exp = &quot;(&quot; logic_exp &quot;)&quot;;

number = [0-9]+ (&quot;.&quot; number)? ;

identifier = [a-zA-Z_][a-zA-Z0-9_]* ;

extern_identifier = (identifier &quot;::&quot;)* identifier ;

bool_const =
    | &quot;true&quot;
    | &quot;false&quot;
    ;

compare_exp =
    | add_exp ((&quot;&lt;=&quot; | &quot;&lt;&quot;｜&quot;&gt;=&quot;｜&quot;&gt;&quot;｜&quot;==&quot;｜&quot;!=&quot;) add_exp)*
    ;

logic_exp = 
    | compare_exp ((&quot;&amp;&amp;&quot;｜&quot;||&quot;) compare_exp)*
    ;

struct_init_exp = 
    | type_name &quot;{&quot; (struct_init_exp_field (&quot;,&quot; struct_init_exp_field)* )? &quot;}&quot; 
    ;

struct_init_exp_field = identifier &quot;:&quot; logic_exp ;

assignee = pointer_exp;

assignment = assignee &quot;=&quot; logic_exp ;

new_variable = &quot;let&quot; identifier &quot;=&quot; logic_exp ;

global_variable = &quot;const&quot; identifier &quot;=&quot; logic_exp ;

if_statement = &quot;if&quot; logic_exp statement_block (&quot;else&quot; if_statement | statement_block)?;

while_statement = &quot;while&quot; logic_exp statement_block ;

for_statement = &quot;for&quot; (assignment | new_variable) &quot;;&quot; logic_exp &quot;;&quot; assignment statement_block;

statement_block = &quot;{&quot; statements &quot;}&quot; ;

impl_block = &quot;impl&quot; extern_identifier &quot;{&quot; function_def* &quot;}&quot; ;

statements = statement* ;

break_statement = &quot;break&quot; &quot;;&quot; ;

continue_statement = &quot;continue&quot; &quot;;&quot; ;

statement = 
    | assignment &quot;;&quot;
    | new_variable &quot;;&quot;
    | return_statement
    | if_statement
    | while_statement
    | break_statement
    | continue_statement
    | complex_exp &quot;;&quot;
    ;

toplevel_statement = 
    | struct_def
    | function_def
    | global_variable
    | use_statement &quot;;&quot;
    ;

program = toplevel_statement* ;

function_def = &quot;fn&quot; identifier &quot;(&quot; (typed_identifier (&quot;,&quot;typed_identifier)*)? &quot;)&quot; type_name (statement_block | &quot;;&quot;) ;

generic_type = &quot;&lt;&quot; type_name (&quot;|&quot; type_name)* &quot;&gt;&quot; ;

generic_type_def = &quot;&lt;&quot; identifier (&quot;|&quot; identifier)* &quot;&gt;&quot; ;

struct_def = &quot;struct&quot; identifier generic_type_def? &quot;{&quot; struct_field* &quot;}&quot; ;

type_name = &quot;*&quot;* extern_identifier ;

typed_identifier = identifier &quot;:&quot; type_name ;

struct_field = typed_identifier &quot;;&quot; ;

return_statement = &quot;return&quot; logic_exp &quot;;&quot; ;

use_statement = &quot;use&quot; identifier (&quot;::&quot; identifier)* &quot;;&quot; ;

string_literal = &quot;\&quot;&quot; [^&quot;]* &quot;\&quot;&quot; ;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-a-short-introduction-to-the-language"><a class="header" href="#quick-start-a-short-introduction-to-the-language">Quick Start: A short introduction to the language</a></h1>
<blockquote>
<p>重要：Pivot lang尚属于早期开发阶段，可能会经常发生breaking change，因此不建议在生产环境中使用。</p>
</blockquote>
<p>本教程将会从安装出发，简单介绍Pivot lang的语法，以及一些基本的使用规则。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="选择你需要的编译模型"><a class="header" href="#选择你需要的编译模型">选择你需要的编译模型</a></h2>
<p>Pivot Lang存在两种不同的编译方案：</p>
<ul>
<li>静态编译：编译器会将源码编译成一个可执行文件，能给在操作系统上原生运行</li>
<li>jit编译：编译器会将源码编译成一个字节码文件，然后在运行时使用编译器指令进行解释执行</li>
</ul>
<p>目前这两种方案使用的编译器是同一个可执行文件（plc），然而他们在依赖和功能上存在一些差别，
下方是一个简单的对比图：</p>
<table><thead><tr><th></th><th>jit</th><th>静态编译</th></tr></thead><tbody>
<tr><td>完整的pivot lang功能支持</td><td>✅</td><td>✅</td></tr>
<tr><td>生成可执行文件</td><td>❌</td><td>✅</td></tr>
<tr><td>启动速度</td><td>❌</td><td>✅</td></tr>
<tr><td>依赖llvm</td><td>❌</td><td>✅</td></tr>
<tr><td>依赖预编译的pivot lang系统库</td><td>❌</td><td>✅</td></tr>
<tr><td>运行时优化</td><td>✅</td><td>❌</td></tr>
<tr><td>支持debug</td><td>❌</td><td>✅</td></tr>
</tbody></table>
<p>可以看出，just in time模式的编译器依赖比静态编译少很多，因此如果你不需要debug功能，建议使用jit模式。如果你想要体验完整功能，建议使用静态编译。</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>TODO</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>目前我们对Ubuntu 20.04 LTS 和 Ubuntu 22.04 LTS提供了apt包。<br />
首先你需要添加我们的apt源的gpg key：</p>
<pre><code class="language-bash">wget -O -  https://apt.lang.pivotstudio.cn/public.key | sudo apt-key add -
</code></pre>
<p>然后添加我们的apt源：</p>
<pre><code class="language-bash">sudo add-apt-repository &quot;deb [arch=amd64] https://apt.lang.pivotstudio.cn/repo focal main&quot;
sudo add-apt-repository &quot;deb [arch=amd64] https://apt.lang.pivotstudio.cn/repo jammy main&quot;
</code></pre>
<p>最后安装pivot lang编译器：</p>
<pre><code class="language-bash">sudo apt install pivot-lang
</code></pre>
<p>你可以运行<code>plc</code>来检查是否安装成功。</p>
<p>请重启当前bash或者运行<code>source ~/.bashrc</code>来使环境变量生效。如果想安装<code>AOT</code>功能，请手动下载clang-14，下载方式见<a href="https://apt.llvm.org/">此处</a></p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>目前最新版MacOS（非英特尔芯片）上的编译器可以使用<code>homebrew</code>进行安装。</p>
<p>首先你需要添加我们的homebrew tap：</p>
<pre><code class="language-bash">brew tap pivot-studio/tap
</code></pre>
<p>然后安装pivot lang编译器：</p>
<pre><code class="language-bash">brew install pivot-lang
</code></pre>
<p>安装完成后请按照提示设置环境变量</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础项目"><a class="header" href="#基础项目">基础项目</a></h1>
<h2 id="项目结构-1"><a class="header" href="#项目结构-1">项目结构</a></h2>
<p>一个最基础的pivot lang项目由一个配置文件和一个源文件组成。配置文件用于指定项目的一些基本信息，源文件用于编写pivot lang代码。其结构如下：</p>
<pre><code>.
├── Kagari.toml
└── main.pi
</code></pre>
<h3 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h3>
<p>一个pl项目的根目录必须有一个名为<code>Kagari.toml</code>的配置文件。示例配置文件的内容如下：</p>
<pre><code class="language-toml">entry = &quot;main.pi&quot;
project = &quot;main&quot;
</code></pre>
<p>entry指定了该项目的入口文件，即编译器将从该文件开始编译。如果缺少该配置<code>plc</code>将无法编译该项目</p>
<h3 id="源文件"><a class="header" href="#源文件">源文件</a></h3>
<p>示例项目中的<code>main.pi</code>为源文件。其内容如下：</p>
<pre><code class="language-pl">use std::io;
fn main() i64 {
    io::printi64ln(666);
    return 0;
}

</code></pre>
<p>源文件的后缀名必须为<code>.pi</code>。<br />
在示例中，我们调用了一个系统库重的函数<code>printi64ln</code>，该函数用于打印一个i64类型的值并换行。此源代码编译后执行会输出<code>666</code>。</p>
<blockquote>
<p>重要：<code>printi64ln</code>函数是目前pl runtime中的一个测试用内置函数，此函数可能会在未来移除</p>
</blockquote>
<h2 id="编译"><a class="header" href="#编译">编译</a></h2>
<p>如果你已经安装了<code>plc</code>，那么你可以在项目根目录下执行<code>plc main.pi</code>命令来编译该项目。此指令会生成一个名叫<code>out.bc</code>的文件，还有一些中间文件</p>
<blockquote>
<p>如果你配置了静态编译环境，还会生成一个叫做<code>out</code>的文件，该文件是一个可执行文件，可以直接运行
而如果你只有jit环境，该文件不会生成，并且编译命令会输出一个clang报错和两行warning，这是正常现象</p>
</blockquote>
<h2 id="jit运行"><a class="header" href="#jit运行">jit运行</a></h2>
<p>编译后输入<code>plc run out.bc</code>可以jit运行该项目，其输出结果如下：</p>
<pre><code>666
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-support"><a class="header" href="#visual-studio-code-support">Visual Studio Code support</a></h1>
<p>我们建议开发者使用Visual Studio Code作为开发工具，因为我们提供了丰富的插件支持。</p>
<h2 id="vsc插件安装"><a class="header" href="#vsc插件安装">vsc插件安装</a></h2>
<p>在vsc插件市场搜索<code>pivot-lang support</code>，安装第一个即可
<img src="tutorial/2022-10-23-00-17-08.png" alt="" /></p>
<blockquote>
<p>注意：pivot-lang support插件依赖于plc命令，你必须确保plc文件安装路径在环境变量<code>PATH</code>中</p>
</blockquote>
<h2 id="支持功能"><a class="header" href="#支持功能">支持功能</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
vsc debug
<ul>
<li><input disabled="" type="checkbox" checked=""/>
断点</li>
<li><input disabled="" type="checkbox" checked=""/>
变量表
<ul>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
代码高亮</li>
<li><input disabled="" type="checkbox" checked=""/>
lsp支持
<ul>
<li><input disabled="" type="checkbox" checked=""/>
错误容忍
<ul>
<li><input disabled="" type="checkbox" checked=""/>
parser错误容忍</li>
<li><input disabled="" type="checkbox" checked=""/>
ast错误容忍</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
代码提示
<ul>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
函数</li>
<li><input disabled="" type="checkbox" checked=""/>
类型</li>
<li><input disabled="" type="checkbox" checked=""/>
模块</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
代码跳转
<ul>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
函数</li>
<li><input disabled="" type="checkbox" checked=""/>
类型</li>
<li><input disabled="" type="checkbox"/>
模块</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
引用查找
<ul>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
函数</li>
<li><input disabled="" type="checkbox" checked=""/>
类型</li>
<li><input disabled="" type="checkbox"/>
模块</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
语法高亮</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>语言功能的参考文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<p>模块化</p>
<h2 id="模块的划分和使用"><a class="header" href="#模块的划分和使用">模块的划分和使用</a></h2>
<p>总体来说，pl的模块化与rust类似，但是规则比rust简单。<br />
任何一个pl文件都是一个模块，模块的名字就是文件名。一个pl项目的根目录一定有<code>Kagari.toml</code>配置文件，之后所有该项目
模块的路径都是从该文件所在的目录开始计算的。</p>
<p>举个例子，如果我的pl项目有以下的目录结构：</p>
<pre><code class="language-text">test
├── Kagari.toml
├── mod1.pi
├── main.pi
└── sub
    └── mod.pi

</code></pre>
<p>如果<code>main.pi</code>想使用<code>mod1.pi</code>或者<code>mod.pi</code>中的函数，那么可以这样写：</p>
<pre><code class="language-pivot-lang">use mod1;
use sub::mod;

fn main() void {
    mod1::func();
    mod::func();
    return;
}
</code></pre>
<p>如果<code>mod.pi</code>想使用<code>mod1.pi</code>中的函数，那么可以这样写：</p>
<pre><code class="language-pivot-lang">use mod1;

fn main() void {
    mod1::func();
    return;
}

</code></pre>
<blockquote>
<p>！！！目前，pl的模块<strong>不支持</strong>循环引用，循环引用可能导致lsp崩溃。</p>
</blockquote>
<blockquote>
<p>！！！目前pl引入的所有模块必须对应到相对的pi文件（不能对应目录，也不能单独引入函数），而且不能引入同名的模块。</p>
</blockquote>
<h2 id="引用另一个pl项目"><a class="header" href="#引用另一个pl项目">引用另一个pl项目</a></h2>
<p>目前只支持引用本地的pl项目，引用的方式是在<code>Kagari.toml</code>中添加<code>[deps]</code> </p>
<pre><code class="language-toml">[deps]
sub3 = { path = &quot;sub2&quot; }
</code></pre>
<p>使用时，引用的项目模块会在<code>deps</code>中定义的命名空间之下：</p>
<pre><code class="language-pivot-lang">use sub3::lib;

fn main() void {
    lib::func();
    return;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method"><a class="header" href="#method">Method</a></h1>
<p>method就是隶属于某个结构体的函数，它们与普通函数<strong>没有</strong>本质区别。<br />
所有的method都必须在impl块里声明，且method都会隐式的有个<code>self</code>参数，该参数是<code>impl</code>类型的指针 </p>
<blockquote>
<p>为什么pivot-lang的receiver是隐式的？因为我们有gc，所以没必要像rust那样显示的声明receiver类型，统一指针就可以解决几乎所有情况。</p>
</blockquote>
<blockquote>
<p>可能存在的问题：不方便约束receiver不可变的情况</p>
</blockquote>
<h2 id="method-example"><a class="header" href="#method-example">Method Example</a></h2>
<p>最简单的添加method的例子：</p>
<pre><code class="language-pivot-lang">impl pointer_struct {
    fn name() void {
        io::printi64ln(100100);
        return;
    }

    fn name_params(x: i64) void {
        return;
    }

}

</code></pre>
<p>在一个包中，可以定义外部引入的包中结构体的<code>method</code> . </p>
<pre><code class="language-pivot-lang">
</code></pre>
<p>调用method的时候，使用<code>&lt;receiver类型&gt;.&lt;method&gt;</code>即可 </p>
<pre><code class="language-pivot-lang">let a = A{};
a.method();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler"><a class="header" href="#compiler">Compiler</a></h1>
<p>pivot-lang编译器（以下简称编译器）主要由三个部分组成：nom分析器、ast和llvm后端。</p>
<h2 id="nom-parser"><a class="header" href="#nom-parser">Nom parser</a></h2>
<p>nom parser包含了编译器的词法分析和语法分析部分。nom parser的主要功能是使用递归下降法将pivot-lang源代码转换为ast。</p>
<h2 id="ast"><a class="header" href="#ast">AST</a></h2>
<p>AST是抽象语法树的简称，是编译器的中间表示。AST是由nom parser生成的，它是一个树形结构，每个节点都是一个结构体，包含了节点的类型、子节点、行号、列号等信息。</p>
<h2 id="llvm-backend"><a class="header" href="#llvm-backend">LLVM backend</a></h2>
<p>本编译器使用llvm来生成目标代码，llvm的jit部分会被包含在我们的编译器可执行文件中，然而静态编译不行。因此静态编译相比jit会多一个llvm的依赖。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser">Parser</a></h1>
<p>parser源代码位置位于<code>src/nomparser</code>目录下，包含了词法分析和语法分析部分。</p>
<h2 id="nom"><a class="header" href="#nom">nom</a></h2>
<p><a href="https://github.com/Geal/nom">nom</a>是一个用rust编写的parser combinator库，它不像lr分析器一样提供生成代码的功能，而是
提供一组函数，这些函数可以用来组合出各种parser。</p>
<p>相比于lr分析器，nom的优点是它的parser combinator非常灵活，熟练后可以快速组合出各种parser，
而且可自定义性非常的强，看起来也很直观，相比很多ir生成器的语法并没有复杂多少，但是带来了更好的
语法支持（一般的ir分析生成器的语法定义文件不会有编程语言那么好的语法支持）。</p>
<p>会使用nom是读懂编译器parser代码的重要前提，这里强烈推荐两个nom文档：</p>
<ul>
<li><a href="https://github.com/Geal/nom/blob/main/doc/nom_recipes.md">Nom Recipes</a></li>
<li><a href="https://github.com/Geal/nom/blob/main/doc/choosing_a_combinator.md">choosing a combinator</a></li>
</ul>
<h2 id="parser结构"><a class="header" href="#parser结构">parser结构</a></h2>
<p>parser的主要功能是使用递归下降法将pivot-lang源代码转换为ast。如果你不了解递归下降法，可以先看看<a href="https://ruslanspivak.com/lsbasi-part1/">这篇文章</a>。</p>
<p>对于pivot lang的每一条语法规则，都会在parser里对应一个分析函数，这些分析函数可能会调用其他分析函数，最终最上层的分析函数可以将完整的源代码转换为ast。</p>
<p>pivot lang的完整语法规则见<a href="compiler/../../../#grammar">这里</a></p>
<p>parser最顶层的函数是<code>parse</code>，它接受一个源文件输出一个AST根节点。</p>
<pre><code class="language-rust no_run noplayground">#[salsa::tracked(lru = 32)]
pub fn parse(db: &amp;dyn Db, source: SourceProgram) -&gt; Result&lt;ProgramNodeWrapper, String&gt; {
    let text = source.text(db);
    let re = program(Span::new(text));
    if let Err(e) = re {
        return Err(format!(&quot;{:?}&quot;, e));
    }
    log::info!(&quot;parse {:?}&quot;, source.path(db));
    Ok(ProgramNodeWrapper::new(db, re.unwrap().1))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-1"><a class="header" href="#ast-1">AST</a></h1>
<p>抽象语法树是目前编译器中最复杂的部分，它是编译器的中间表示，也是编译器的核心。本节将介绍AST的设计和实现。</p>
<h2 id="ast的设计"><a class="header" href="#ast的设计">AST的设计</a></h2>
<p>基本上，所有源代码中的基础单位都会对应抽象语法树中的一个节点。抽象语法树有很多类型的节点，他们可能会相互引用。</p>
<p>所有的节点都必须实现<code>Node</code> trait，这个trait定义了节点的基本行为。</p>
<pre><code class="language-rust no_run noplayground">#[enum_dispatch]
pub trait Node: RangeTrait + AsAny + FmtTrait {
    fn print(&amp;self, tabs: usize, end: bool, line: Vec&lt;bool&gt;);
    fn emit&lt;'a, 'ctx, 'b&gt;(
        &amp;mut self,
        ctx: &amp;'b mut Ctx&lt;'a&gt;,
        builder: &amp;'b BuilderEnum&lt;'a, 'ctx&gt;,
    ) -&gt; NodeResult;
}
</code></pre>
<p>你可能注意到了，<code>Node</code>trait继承了<code>RangeTrait</code>，这个trait定义了节点的位置信息。</p>
<pre><code class="language-rust no_run noplayground">#[enum_dispatch]
pub trait RangeTrait {
    fn range(&amp;self) -&gt; Range;
}
</code></pre>
<p>一般来说，<code>RangeTrait</code>的实现通过<code>#[range]</code>宏来自动生成，你不需要手动实现它。</p>
<p><code>Node</code>接口中的<code>print</code>函数用于打印节点的信息，它会被用于调试。<code>print</code>打印的结果和<code>tree</code>的输出非常像，你需要用一些工具函数来
格式化输出。以<code>ifnode</code>的<code>print</code>函数为例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn print(&amp;self, tabs: usize, end: bool, mut line: Vec&lt;bool&gt;) {
        deal_line(tabs, &amp;mut line, end);
        tab(tabs, line.clone(), end);
        println!(&quot;IfNode&quot;);
        self.cond.print(tabs + 1, false, line.clone());
        if let Some(el) = &amp;self.els {
            self.then.print(tabs + 1, false, line.clone());
            el.print(tabs + 1, true, line.clone());
        } else {
            self.then.print(tabs + 1, true, line.clone());
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>emit</code>函数是生成llvm代码的核心，它会调用llvm api构造自己对应的llvm ir。在编译的时候，最上层节点的<code>emit</code>会被调用，
该函数会递归的调用自己的子节点的<code>emit</code>函数，最终生成整个程序的llvm ir。<br />
下方是<code>ifnode</code>的<code>emit</code>函数：</p>
<pre><code class="language-rust no_run noplayground">    fn emit&lt;'a, 'ctx, 'b&gt;(
        &amp;mut self,
        ctx: &amp;'b mut Ctx&lt;'a&gt;,
        builder: &amp;'b BuilderEnum&lt;'a, 'ctx&gt;,
    ) -&gt; NodeResult {
        let cond_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.cond&quot;);
        let then_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.then&quot;);
        let else_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.else&quot;);
        let after_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.after&quot;);
        builder.build_unconditional_branch(cond_block);
        ctx.position_at_end(cond_block, builder);
        let condrange = self.cond.range();
        let (cond, pltype, _) = self.cond.emit(ctx, builder)?;
        if pltype.is_none() || !pltype.clone().unwrap().borrow().is(&amp;PriType::BOOL) {
            return Err(ctx.add_err(condrange, ErrorCode::IF_CONDITION_MUST_BE_BOOL));
        }
        let (cond, _) = ctx.try_load2var(condrange, cond.unwrap(), pltype.unwrap(), builder)?;
        let cond = builder.build_int_truncate(cond, &amp;PriType::BOOL, &quot;trunctemp&quot;);
        builder.build_conditional_branch(cond, then_block, else_block);
        // then block
        ctx.position_at_end(then_block, builder);
        let (_, _, then_terminator) = self.then.emit_child(ctx, builder)?;
        if then_terminator.is_none() {
            builder.build_unconditional_branch(after_block);
        }
        ctx.position_at_end(else_block, builder);
        let terminator = if let Some(el) = &amp;mut self.els {
            let mut child = ctx.new_child(el.range().start, builder);
            let (_, _, else_terminator) = el.emit(&amp;mut child, builder)?;
            if else_terminator.is_none() {
                builder.build_unconditional_branch(after_block);
            }
            if then_terminator.is_return() &amp;&amp; else_terminator.is_return() {
                TerminatorEnum::RETURN
            } else {
                TerminatorEnum::NONE
            }
        } else {
            builder.build_unconditional_branch(after_block);
            TerminatorEnum::NONE
        };
        ctx.position_at_end(after_block, builder);
        if terminator.is_return() {
            builder.build_unconditional_branch(after_block);
        }
        ctx.emit_comment_highlight(&amp;self.comments[0]);
        Ok((None, None, terminator))
    }
</code></pre>
<p>emit函数的参数是节点自身，第二个参数是编译上下文。编译上下文中会包含一些需要透传的信息，比如符号表，llvmbuilder，lsp参数等。</p>
<h2 id="打印ast结构"><a class="header" href="#打印ast结构">打印AST结构</a></h2>
<p>plc命令行工具有打印ast的功能，你可以使用<code>plc xxx.pi --printast</code>命令来打印ast结构。<br />
下方是一个ast打印结果的样例：</p>
<pre><code class="language-ast">...
file: /Users/bobli/src/pivot-lang/test/sub/mod.pi
ProgramNode
 └─ FuncDefNode
     ├─ id: name
     ├─ TypeNameNode
     │   └─ ExternIdNode
     │       └─ VarNode: void
     └─ StatementsNode
         └─ RetNode
file: /Users/bobli/src/pivot-lang/test/mod2.pi
ProgramNode
 ├─ UseNode
 │   ├─ VarNode: sub
 │   └─ VarNode: mod
 ├─ FuncDefNode
 │   ├─ id: test_mod
 │   ├─ TypedIdentifierNode
 │   │   ├─ id: args
 │   │   └─ TypeNameNode
 │   │       └─ ExternIdNode
 │   │           └─ VarNode: i64
 │   ├─ TypeNameNode
 │   │   └─ ExternIdNode
 │   │       └─ VarNode: void
 │   └─ StatementsNode
 │       └─ RetNode
 └─ StructDefNode
     ├─ id: Mod2
     └─ TypedIdentifierNode
         ├─ id: y
         └─ TypeNameNode
             └─ ExternIdNode
                 └─ VarNode: bool
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-server"><a class="header" href="#language-server">Language Server</a></h1>
<p>Pivot Lang的Language Server（以下简称LSP）是一个用于为编译器提供语法支持的组件，它同时被用于在编译期间生成诊断信息。</p>
<blockquote>
<p>基本上，lsp能够为所有的现代代码编辑器提供服务，但是目前我们只为vsc提供官方支持。如果想在别的编辑器中使用lsp，可能需要自己写一个
简单的客户端插件。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计design"><a class="header" href="#设计design">设计(design)</a></h1>
<p>pivot-lang的lsp功能被内置于编译器中，它是以差量计算（incremental）为前提设计的。
目前整个lsp程序几乎是完全单线程的，但得益于我们的差量计算，它仍然具有不错的性能。</p>
<h2 id="1-差量计算incremental"><a class="header" href="#1-差量计算incremental">1. 差量计算(incremental)</a></h2>
<p>差量计算是指在编译器中，当源代码发生修改时，我们只对发生变化的部分进行重新分析，而不是对整个项目全部重新进行计算。</p>
<p>pivot-lang的差量计算是基于rust的<a href="https://github.com/salsa-rs/salsa">salsa</a>库实现的。
我们使用的版本是仍然处于预览阶段的<code>salsa_2022</code>。</p>
<p>pl中的差量计算的最小复用单元是<code>Module</code>，即一个源文件。</p>
<p>在plc作为lsp运行时，所有的lsp功能相关计算会在<code>TextDocumentEdit</code>事件发生时进行，之后如果不进行文本编辑，所有的
lsp请求都会直接从缓存中读取结果。</p>
<h2 id="2-差量计算举例"><a class="header" href="#2-差量计算举例">2. 差量计算举例</a></h2>
<p>假设我们有一个pl项目，其中有三个文件：<code>a.pi</code>、<code>b.pi</code>、<code>c.pi</code>。
其中<code>a.pi</code>和<code>b.pi</code>都引用了<code>c.pi</code>中的函数<code>f</code>，并且<code>a.pi</code>中还使用了<code>b.pi</code>中的函数<code>g</code>。</p>
<p>此时，当我们用vsc打开此pl项目，vsc会启动plc进行分析。如果没使用差量计算，那么plc分析流程如下：</p>
<pre><code>尝试分析a.pi-&gt;
依赖c.pi-&gt;
分析c.pi-&gt;
返回继续分析a.pi-&gt;
依赖b.pi-&gt;
分析b.pi-&gt;
依赖c.pi-&gt;
分析c.pi-&gt;
返回继续分析b.pi-&gt;
返回继续分析a.pi-&gt;
完成
</code></pre>
<p>可以看到<code>c.pi</code>被分析了两次，这是不必要的。差量分析在这一步中可以优化掉第二次对<code>c.pi</code>的分析。</p>
<p>然后，假设我们在<code>a.pi</code>中添加了一个字符，那么如果没采用差量分析法，所有的模块都会被重新分析一遍。而差量分析法只会对<code>a.pi</code>进行重新分析。</p>
<p>接着，如果我们改动了<code>b.pi</code>，那么差量分析法会对<code>b.pi</code>和<code>a.pi</code>进行重新分析，而不会对<code>c.pi</code>进行重新分析。<strong>即：每次修改文件时，只会对该文件以及依赖该文件的文件进行重新分析。</strong></p>
<h2 id="3-验证差量计算是否正常工作"><a class="header" href="#3-验证差量计算是否正常工作">3. 验证差量计算是否正常工作</a></h2>
<p>我们可以在vsc的选项中找到一个plc的<code>Log Level</code>选项，将它设置成<code>2</code>之后就能看到plc的<code>info</code>日志了。<br />
<img src="lsp/2022-12-08-13-20-37.png" alt="" /></p>
<blockquote>
<p>日志可以在vsc的outut中选择<code>pivot-lang language server</code>查看
<img src="lsp/2022-12-08-13-22-04.png" alt="" /></p>
</blockquote>
<p>这里会在每次重新计算的时候输出对应的log。</p>
<h2 id="一些坑点"><a class="header" href="#一些坑点">一些坑点</a></h2>
<h3 id="salsa-lru与internedtracked类型"><a class="header" href="#salsa-lru与internedtracked类型">salsa lru与interned、tracked类型</a></h3>
<p><code>salsa</code>的lru缓存实际上缓存的key是<code>salsa</code>结构体的值，而不是实际值。也就是说，即使实际值一样，如果<code>salsa</code>结构体的值不同，那么缓存也会失效。</p>
<p>所以，如果使用lru缓存的函数的输入是<code>tracked</code>类型的结构体，必须输入完全一致的对象才能触发缓存逻辑。
<strong>如果你的结构体是<code>new</code>的则一定无法触发缓存逻辑</strong>。</p>
<p>因此，建议在需要缓存的函数中使用<code>interned</code>类型的结构体作为参数。因为<code>interned</code>每次<code>new</code>的时候会去db中检索值，
如果值已经存在则会返回已有的<code>salsa struct</code>，而不会<code>new</code>一个新的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diagnostic"><a class="header" href="#diagnostic">Diagnostic</a></h1>
<p>诊断信息是个非常重要的功能，它可以帮助我们在编写代码的时候发现错误和可能有问题的地方，从而提高我们的编码效率。</p>
<p>为了让用户体验尽可能的好，我们的lsp分析需要尽量容忍用户的错误输入，尽可能多的分析出用户代码中的问题</p>
<h2 id="fault-tolerance"><a class="header" href="#fault-tolerance">Fault Tolerance</a></h2>
<p>错误容忍是生成好的诊断信息的前提。在pivot-lang的中，我们分别在两个层面上实现了错误容忍：</p>
<ul>
<li>parser</li>
<li>ast</li>
</ul>
<h3 id="parser的错误容忍"><a class="header" href="#parser的错误容忍">Parser的错误容忍</a></h3>
<p>nom parser架构中，如果出现了一个无法被识别的语句，整个分析器就会终止分析输出错误。这对于错误容忍的要求来说是无法被接受的。所以
我们的编译器不使用nom parser的默认错误处理机制，任何parser阶段产生的nom error都应该被视作<strong>bug</strong>，我们应该尽可能的避免这种情况。</p>
<p>在parse过程中，如果一些错误语句能非常明显的被识别为一个语法的未完成项（且没有歧义），我们应该将它识别为该语法类型的Node，并且在Node上加一个
flag标识它不完整（常常是<code>is_complete</code>），这样在ast阶段我们就能输出对应的诊断信息。</p>
<p>对于最常见的基础语法单位<code>statement</code>和<code>top_statement</code>，parser提供了一个helper函数<code>except</code>，能够在遇到不可被识别的错误语句的时候
将该“块”语句识别为<code>ErrNode</code>，以方便后续的分析正常进行。</p>
<blockquote>
<p>！！！<strong>注意</strong>：ErrNode虽然很好用，但是它只能输出很宽泛的诊断信息（比如无法识别该语句），它是最后的错误容忍手段，应该尽量避免使用它</p>
</blockquote>
<h3 id="ast的错误容忍"><a class="header" href="#ast的错误容忍">AST的错误容忍</a></h3>
<p>由于parse阶段的时候能够容忍错误的语句，对于一些语法错误，ast节点只需要检查自身的完整性就能够输出诊断信息了。而对于语义错误（例如类型不匹配），我们需要在ast阶段
进行分析并获取结果。这些操作目前是在各个节点的<code>emit</code>函数里进行的。所有的<code>emit</code>函数都返回<code>NodeResult</code>类型，如果该节点的<code>emit</code>中出现了错误，
分析将会中断，其对应的错误信息会被添加到<code>ctx</code>（编译上下文）中并且作为<code>error</code>返回。上层函数如果遇到自己依赖的函数报错<strong>一定不能重复添加该错误至<code>ctx</code>中</strong>，
否则会导致错误信息重复输出。上层函数处理自己的依赖报错有两种情况：</p>
<ul>
<li>直接停止分析并将该错误传递给自己的上级</li>
<li>忽略该错误继续进行分析</li>
</ul>
<p>一般来说，大部分的expression和statement都会采用第一种方案，而statement block则会采用第二种方案</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemlib"><a class="header" href="#systemlib">SystemLib</a></h1>
<p>pl的系统库一部分是pl代码一部分是rust代码，rust部分在项目的<code>vm</code>目录中，pl部分在<code>planglib</code>目录中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm"><a class="header" href="#vm">VM</a></h1>
<p>放rust写的给pivot-lang使用的函数</p>
<p>所有导出的函数需要加<code>#[is_runtime]</code>，所有导出结构体需要加<code>#[repr(C)]</code></p>
<h2 id="jit-invalid-memory-access-issue"><a class="header" href="#jit-invalid-memory-access-issue">JIT invalid memory access issue</a></h2>
<p>在jit模式下使用runtime函数可能会出现<code>invalid memory access</code>错误，
这个问题本质是rust编译的时候会优化掉不使用的module，导致jit时找不到对应runtime函数。所以建议每个
mod加一个叫做<code>reg</code>的函数，里边<strong>必须用到你会使用的所有结构体</strong>，这样在需要jit测试的时候调用使用模块的<code>reg</code>函数，对应代码就不会被优化掉了。</p>
<h2 id="使用is_runtime导出rust函数"><a class="header" href="#使用is_runtime导出rust函数">使用<code>is_runtime</code>导出rust函数</a></h2>
<p>一个被<code>is_runtime</code>标记的rust函数在编译到静态库之后，在pivot-lang中声明对应的函数，即可像正常函数一样调用。例如：</p>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[is_runtime]
fn printi64ln(i: i64) {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>Pivot Lang:</p>
<pre><code class="language-pivot-lang">fn printi64ln(i: i64) void

fn main() void {
    printi64ln(1)
    return
}
</code></pre>
<blockquote>
<p>！！！<strong>注意事项</strong>：<code>is_runtime</code>标记的函数不能有modifier（比如<code>pub</code>，<code>unsafe</code>），但是被<code>is_runtime</code>标记的<code>impl</code>块中的函数不受此限制。</p>
<pre><code class="language-rust ignore">struct MyStruct;
#[is_runtime(&quot;struct&quot;)]
impl MyStruct {
  pub fn myfunc1() {
      // ...
   }
}
</code></pre>
<p>标记impl块时，导出的函数名称会变为<code>{structname}__{fnname}</code>的形式，函数允许使用receiver。更多高级用法参见<code>is_runtime</code>的rust doc</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gc"><a class="header" href="#gc">GC</a></h1>
<p>pivot-lang 是一门使用gc进行内存管理的语言。<br />
pivot-lang 的gc目前是使用rust写的，采用非常简单的 <code>mark and sweep</code> 算法。
栈变量采用<code>shadow stack</code>模式进行追踪。<br />
目前gc的源代码在vm项目中</p>
<blockquote>
<p>目前的gc非常简单，也没做任何优化，属于能用就行。总代码量也很少，欢迎为我们改进它。</p>
</blockquote>
<h2 id="shadow-stack"><a class="header" href="#shadow-stack">Shadow Stack</a></h2>
<p>pl的gc目前是精确gc，编译器会插入指令以让gc运行时能知道gcroot有哪些。gc记录的gcroot列表就是<code>shadow stack</code>。
在mark阶段，gc会从<code>shadow stack</code>开始扫描。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planglib"><a class="header" href="#planglib">planglib</a></h1>
<p>planglib目录下的每一个文件夹都是一个系统模块，在编译的时候会自动被加入依赖中，不需要在配置文件中特殊配置。</p>
<h2 id="planglib如何在编译期间被找到"><a class="header" href="#planglib如何在编译期间被找到">planglib如何在编译期间被找到</a></h2>
<p>plc编译器在编译时会试图寻找<code>KAGARI_LIB_ROOT</code>环境变量，并且将该变量视为<code>planglib</code>的根目录</p>
<blockquote>
<p>不设置或错误设置<code>KAGARI_LIB_ROOT</code>环境变量可能导致无法进行编译或者代码分析</p>
</blockquote>
<p>如果你是plang开发者，你可以手动在<code>~/.bashrc</code>或者<code>~/.bash_profile</code>中加入以下代码：</p>
<pre><code class="language-bash">export KAGARI_LIB_ROOT=&lt;pivot-lang project path&gt;/planglib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为pivot-lang贡献代码"><a class="header" href="#为pivot-lang贡献代码">为Pivot Lang贡献代码</a></h1>
<p>非常感谢您愿意对本项目提供帮助！</p>
<p>下方是对您为 <a href="https://github.com/Pivot-Studio/pivot-lang">pivot-lang</a> 贡献代码的一些帮助</p>
<p>如果您刚开始了解pivot-lang项目，可以加入我们的社区 <a href="https://jq.qq.com/?_wv=1027&amp;k=I5vdShVl">qq 群</a> 向我们提问.</p>
<p><strong>因为本项目还处于早期阶段</strong>: 本页面的指导很可能会在未来有更改，欢迎帮助我们改进此页面！</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<h3 id="开源协议"><a class="header" href="#开源协议">开源协议</a></h3>
<p>本项目使用 <a href="https://opensource.org/licenses/MIT">MIT</a> 协议。对本项目贡献代码即表示您同意您的更改遵守该协议。</p>
<h2 id="您能做的事情"><a class="header" href="#您能做的事情">您能做的事情</a></h2>
<h3 id="issues"><a class="header" href="#issues">Issues</a></h3>
<p>我们有很多的已有的issue，在添加新功能的时候我们也会添加相关的issue。如果您发现我们的bug或者有什么需求，欢迎新建 <a href="https://github.com/Pivot-Studio/pivot-lang/issues">issues</a> 
来告诉我们。您也可以看一些 <a href="https://github.com/Pivot-Studio/pivot-lang/issues?q=is%3Aopen+is%3Aissue">open</a> 的issue并且参与讨论或者贡献代码帮助修复它。</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>非常欢迎帮助我们实现新功能。我们的新功能实现分为几个阶段：</p>
<ul>
<li>提出，讨论需求的合理性和必要性</li>
<li>讨论实现方案</li>
<li>实现</li>
<li>reveiew</li>
<li>合并</li>
</ul>
<p>一些简单的需求可以跳过第二个阶段，所有超过第一个阶段的需求都会被放在我们的<a href="https://github.com/orgs/Pivot-Studio/projects/7/views/1">project</a>中。如果您想帮助实现
已有需求，请去此页面寻找处于new或者ready状态的项目。如果您想实现一个新的需求，请先在<a href="https://github.com/Pivot-Studio/pivot-lang/issues">issues</a>中提出，最好加入
<a href="https://jq.qq.com/?_wv=1027&amp;k=I5vdShVl">qq群</a> 和我们一起讨论方案，在讨论决定通过后，我们会在<a href="https://github.com/orgs/Pivot-Studio/projects/7/views/1">project</a>中添加一个新的对应项目。</p>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<p>强烈建议在提交修改的时候同时添加对应的测试，帮助我们将测试覆盖率保持在 <strong>85%</strong>, 帮助我们进一步完善测试也是相当欢迎的。</p>
<p>请在提交pr前确认自己的修改能通过所有的测试(通过运行 <code>cargo test --all</code>)</p>
<h3 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h3>
<p>目前我们还没有基准测试，欢迎帮助我们添加基准测试。</p>
<h3 id="文档"><a class="header" href="#文档">文档</a></h3>
<p>参见 <a href="https://lang.pivotstudio.cn/">文档</a> 网站。对应源码在 <a href="https://github.com/Pivot-Studio/pivot-lang/tree/master/book">book</a> 目录中，欢迎帮助我们完善文档。</p>
<h2 id="风格"><a class="header" href="#风格">风格</a></h2>
<h3 id="issue-风格"><a class="header" href="#issue-风格">Issue 风格</a></h3>
<p>请在提出issue时提供至少三个小自然段的说明，包括：你想干什么，遇到了什么问题，如果复现这个问题等。</p>
<p>如果可能的话，希望您能提供:</p>
<ul>
<li>如歌是在使用的时候遇到的bug，最好有一小段代码或者一个指向 <a href="https://gist.github.com">gist</a> 的链接，其中包含能复现问题的代码。</li>
<li>完整的 backtrace, 如果是进程崩溃相关的问题。</li>
<li>一个示例项目，如果是编译相关的问题。</li>
</ul>
<h3 id="代码风格"><a class="header" href="#代码风格">代码风格</a></h3>
<p>rust代码风格通过使用 <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> 进行统一 
请尽量减少代码重复率，增加可读性。</p>
<p>为了避免不同的rust小版本格式化的区别，请使用以下命令格式化: <code>cargo +stable fmt</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
