<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pivot Lang</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial/basicproject.html"><strong aria-hidden="true">2.2.</strong> Basic Project</a></li><li class="chapter-item expanded "><a href="tutorial/vscsupport.html"><strong aria-hidden="true">2.3.</strong> VSC Support</a></li></ol></li><li class="chapter-item expanded "><a href="references/index.html"><strong aria-hidden="true">3.</strong> References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references/module.html"><strong aria-hidden="true">3.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="references/method.html"><strong aria-hidden="true">3.2.</strong> Method</a></li><li class="chapter-item expanded "><a href="references/interface.html"><strong aria-hidden="true">3.3.</strong> Trait</a></li><li class="chapter-item expanded "><a href="references/immix.html"><strong aria-hidden="true">3.4.</strong> Immix Gc</a></li><li class="chapter-item expanded "><a href="references/stackmap.html"><strong aria-hidden="true">3.5.</strong> Stack Map</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">How the project works internally</li><li class="chapter-item expanded "><a href="compiler/index.html"><strong aria-hidden="true">4.</strong> Compiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compiler/parser.html"><strong aria-hidden="true">4.1.</strong> Parser</a></li><li class="chapter-item expanded "><a href="compiler/ast.html"><strong aria-hidden="true">4.2.</strong> AST</a></li><li class="chapter-item expanded "><a href="compiler/flow.html"><strong aria-hidden="true">4.3.</strong> Flow Chart</a></li></ol></li><li class="chapter-item expanded "><a href="lsp/index.html"><strong aria-hidden="true">5.</strong> Language Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lsp/design.html"><strong aria-hidden="true">5.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="lsp/diagnostic.html"><strong aria-hidden="true">5.2.</strong> Diagnostic</a></li></ol></li><li class="chapter-item expanded "><a href="systemlib/index.html"><strong aria-hidden="true">6.</strong> System library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="systemlib/vm.html"><strong aria-hidden="true">6.1.</strong> vm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="systemlib/gc.html"><strong aria-hidden="true">6.1.1.</strong> gc</a></li></ol></li><li class="chapter-item expanded "><a href="systemlib/planglib.html"><strong aria-hidden="true">6.2.</strong> planglib</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">CONTRIBUTING</li><li class="chapter-item expanded "><a href="CONTRIBUTING-CN.html"><strong aria-hidden="true">7.</strong> Contributing</a></li><li class="chapter-item expanded affix "><li class="part-title">Blogs</li><li class="chapter-item expanded "><a href="blogs/aboutpl.html"><strong aria-hidden="true">8.</strong> About pivot lang</a></li><li class="chapter-item expanded "><a href="blogs/lsp_and_salsa.html"><strong aria-hidden="true">9.</strong> lsp and salsa</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pivot Lang</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Pivot-Studio/pivot-lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pivot-lang"><a class="header" href="#pivot-lang">Pivot-lang</a></h1>
<p><a href="https://codecov.io/gh/Pivot-Studio/pivot-lang"><img src="https://codecov.io/gh/Pivot-Studio/pivot-lang/branch/master/graph/badge.svg?token=CA17PWK0EG" alt="codecov" /></a> 
<a href="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/release.yml"><img src="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/release.yml/badge.svg" alt="release" /></a>
<a href="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/test.yml"><img src="https://github.com/Pivot-Studio/pivot-lang/actions/workflows/test.yml/badge.svg" alt="test" /></a>
<a href="https://drone.pivotstudio.cn/Pivot-Studio/pivot-lang"><img src="https://drone.pivotstudio.cn/api/badges/Pivot-Studio/pivot-lang/status.svg?ref=refs/heads/gh-pages" alt="docs" /></a></p>
<p><img src="https://codecov.io/gh/Pivot-Studio/pivot-lang/branch/master/graphs/sunburst.svg?token=CA17PWK0EG" alt="codecov" /></p>
<p>此项目目前处于早期开发阶段，不建议用于生产环境。<br />
<a href="https://github.com/Pivot-Studio/pivot-lang">项目地址</a></p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>见<a href="https://lang.pivotstudio.cn/tutorial/installation.html">此处</a></p>
<h2 id="文档地址"><a class="header" href="#文档地址">文档地址</a></h2>
<p>https://lang.pivotstudio.cn</p>
<h2 id="contributing"><a class="header" href="#contributing">CONTRIBUTING</a></h2>
<p><a href="../../CONTRIBUTING.html">CONTRIBUTING</a><br />
中文见<a href="https://lang.pivotstudio.cn/CONTRIBUTING-CN.html">此处</a><br />
欢迎加入<a href="https://jq.qq.com/?_wv=1027&amp;k=I5vdShVl">社区群</a></p>
<h2 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h2>
<ul>
<li><a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-14.0.6">llvm-14</a></li>
<li><a href="https://www.rust-lang.org/">rust</a></li>
</ul>
<p><strong>重要</strong>：如果你想参与开发，请先在项目目录<code>make vm install</code>，然后根据自己是linux还是mac运行<code>make devlinux</code>或者<code>make devmac</code></p>
<h2 id="特点"><a class="header" href="#特点">特点</a></h2>
<ul>
<li>静态编译（jit模式与immix gc不兼容，因为llvm生成自定义stackmap<a href="https://llvm.org/docs/GarbageCollection.html#emitting-assembly-code-gcmetadataprinter">目前必需要静态编译</a>）</li>
<li>极其方便的rust互操作</li>
<li>支持debug</li>
<li>支持lsp，自带vsc插件，能提供优秀的代码支持</li>
</ul>
<h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<ul>
<li><a href="../../vm">vm</a> 包含rumtime</li>
<li><a href="../../src">src</a> 编译器源码所在</li>
<li><a href="../../internal_macro">internal_macro</a> 内部过程宏</li>
</ul>
<h2 id="grammar"><a class="header" href="#grammar">grammar</a></h2>
<pre><code class="language-ebnf">add_exp = 
    | mul_exp (&quot;+&quot; | &quot;-&quot; add_exp)?
    ;

mul_exp = 
    | unary_exp (&quot;*&quot;｜&quot;/&quot; mul_exp)?
    ;

unary_exp =
    | pointer_exp
    | (&quot;-&quot; | &quot;!&quot;) pointer_exp
    ;


pointer_exp = (&quot;&amp;&quot;|&quot;*&quot;)* complex_exp;

complex_exp = primary_exp (take_exp_op|array_element_op|call_function_op)*;

take_exp_op = (&quot;.&quot; identifier) ;

array_element_op = ('[' logic_exp ']') ;

call_function_op = (&quot;(&quot; (logic_exp (&quot;,&quot;logic_exp)*)? &quot;)&quot;) ;

primary_exp =
    | number
    | bool_const
    | parantheses_exp
    | extern_identifier
    | struct_init_exp
    | string_literal
    ;

parantheses_exp = &quot;(&quot; logic_exp &quot;)&quot;;

number = [0-9]+ (&quot;.&quot; number)? ;

identifier = [a-zA-Z_][a-zA-Z0-9_]* ;

extern_identifier = (identifier &quot;::&quot;)* identifier ;

bool_const =
    | &quot;true&quot;
    | &quot;false&quot;
    ;

compare_exp =
    | add_exp ((&quot;&lt;=&quot; | &quot;&lt;&quot;｜&quot;&gt;=&quot;｜&quot;&gt;&quot;｜&quot;==&quot;｜&quot;!=&quot;) add_exp)*
    ;

logic_exp = 
    | compare_exp ((&quot;&amp;&amp;&quot;｜&quot;||&quot;) compare_exp)*
    ;

struct_init_exp = 
    | type_name &quot;{&quot; (struct_init_exp_field (&quot;,&quot; struct_init_exp_field)* )? &quot;}&quot; 
    ;

struct_init_exp_field = identifier &quot;:&quot; logic_exp ;

assignee = pointer_exp;

assignment = assignee &quot;=&quot; logic_exp ;

new_variable = &quot;let&quot; identifier &quot;=&quot; logic_exp ;

global_variable = &quot;const&quot; identifier &quot;=&quot; logic_exp ;

if_statement = &quot;if&quot; logic_exp statement_block (&quot;else&quot; if_statement | statement_block)?;

while_statement = &quot;while&quot; logic_exp statement_block ;

for_statement = &quot;for&quot; (assignment | new_variable) &quot;;&quot; logic_exp &quot;;&quot; assignment statement_block;

statement_block = &quot;{&quot; statements &quot;}&quot; ;

impl_block = &quot;impl&quot; extern_identifier &quot;{&quot; function_def* &quot;}&quot; ;

statements = statement* ;

break_statement = &quot;break&quot; &quot;;&quot; ;

continue_statement = &quot;continue&quot; &quot;;&quot; ;

statement = 
    | assignment &quot;;&quot;
    | new_variable &quot;;&quot;
    | return_statement
    | if_statement
    | while_statement
    | break_statement
    | continue_statement
    | complex_exp &quot;;&quot;
    ;

toplevel_statement = 
    | struct_def
    | function_def
    | global_variable
    | use_statement &quot;;&quot;
    ;

program = toplevel_statement* ;

function_def = &quot;fn&quot; identifier &quot;(&quot; (typed_identifier (&quot;,&quot;typed_identifier)*)? &quot;)&quot; type_name (statement_block | &quot;;&quot;) ;

generic_type = &quot;&lt;&quot; type_name (&quot;|&quot; type_name)* &quot;&gt;&quot; ;

generic_type_def = &quot;&lt;&quot; identifier (&quot;|&quot; identifier)* &quot;&gt;&quot; ;

struct_def = &quot;struct&quot; identifier generic_type_def? &quot;{&quot; struct_field* &quot;}&quot; ;

type_name = &quot;*&quot;* extern_identifier ;

typed_identifier = identifier &quot;:&quot; type_name ;

struct_field = typed_identifier &quot;;&quot; ;

return_statement = &quot;return&quot; logic_exp &quot;;&quot; ;

use_statement = &quot;use&quot; identifier (&quot;::&quot; identifier)* &quot;;&quot; ;

string_literal = &quot;\&quot;&quot; [^&quot;]* &quot;\&quot;&quot; ;

trait_def = &quot;trait&quot; identifier generic_type_def? (&quot;:&quot; type_add)? &quot;{&quot; function_def* &quot;}&quot; ;

type_add = type_name (&quot;+&quot; type_name)* ;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-a-short-introduction-to-the-language"><a class="header" href="#quick-start-a-short-introduction-to-the-language">Quick Start: A short introduction to the language</a></h1>
<blockquote>
<p>重要：Pivot lang尚属于早期开发阶段，可能会经常发生breaking change，因此不建议在生产环境中使用。</p>
</blockquote>
<p>本教程将会从安装出发，简单介绍Pivot lang的语法，以及一些基本的使用规则。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="选择你需要的编译模型"><a class="header" href="#选择你需要的编译模型">选择你需要的编译模型</a></h2>
<p>Pivot Lang存在两种不同的编译方案：</p>
<ul>
<li>静态编译：编译器会将源码编译成一个可执行文件，能给在操作系统上原生运行</li>
<li><del>jit编译：编译器会将源码编译成一个字节码文件，然后在运行时使用编译器指令进行解释执行</del></li>
</ul>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="tutorial/installation.html#admonition-warning"></a></p>
</div>
<div>
<p>目前jit模式暂时不可用，因为它与我们新的immix gc不兼容，详细情况请看<a href="tutorial/../references/stackmap.html">这里</a></p>
</div>
</div>
<p>目前这两种方案使用的编译器是同一个可执行文件（plc），然而他们在依赖和功能上存在一些差别，
下方是一个简单的对比图：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>jit</th><th>静态编译</th></tr></thead><tbody>
<tr><td>完整的pivot lang功能支持</td><td>✅</td><td>✅</td></tr>
<tr><td>生成可执行文件</td><td>❌</td><td>✅</td></tr>
<tr><td>启动速度</td><td>❌</td><td>✅</td></tr>
<tr><td>依赖llvm</td><td>❌</td><td>✅</td></tr>
<tr><td>依赖预编译的pivot lang系统库</td><td>❌</td><td>✅</td></tr>
<tr><td>运行时优化</td><td>✅</td><td>❌</td></tr>
<tr><td>支持debug</td><td>❌</td><td>✅</td></tr>
<tr><td>stackmap支持</td><td>❌</td><td>✅</td></tr>
</tbody></table>
</div>
<p>可以看出，just in time模式的编译器依赖比静态编译少很多，因此如果你不需要debug功能，建议使用jit模式。如果你想要体验完整功能，建议使用静态编译。</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>TODO</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>目前我们对架构为amd64的Ubuntu 20.04 LTS 和 Ubuntu 22.04 LTS提供了apt包。<br />
首先你需要添加我们的apt源的gpg key：</p>
<pre><code class="language-bash">apt update
apt install wget gnupg
wget -O -  https://apt.lang.pivotstudio.cn/public.key | apt-key add -
</code></pre>
<p>然后添加我们的apt源：</p>
<pre><code class="language-bash">echo &quot;deb [arch=amd64] https://apt.lang.pivotstudio.cn/repo focal main
# deb-src [arch=amd64] https://apt.lang.pivotstudio.cn/repo focal main
deb [arch=amd64] https://apt.lang.pivotstudio.cn/repo jammy main
# deb-src [arch=amd64] https://apt.lang.pivotstudio.cn/repo jammy main&quot;&gt;/etc/apt/sources.list.d/pl.list
apt update
</code></pre>
<p>最后安装pivot lang编译器：</p>
<pre><code class="language-bash">apt install pivot-lang
</code></pre>
<p>你可以运行<code>plc</code>来检查是否安装成功。</p>
<p>安装完成后请按照提示设置环境变量</p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>MacOS可以使用<code>homebrew</code>进行安装。</p>
<p>首先你需要添加我们的homebrew tap：</p>
<pre><code class="language-bash">brew tap pivot-studio/tap
</code></pre>
<p>然后安装pivot lang编译器：</p>
<pre><code class="language-bash">brew install pivot-lang
</code></pre>
<p>安装完成后请按照提示设置环境变量</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础项目"><a class="header" href="#基础项目">基础项目</a></h1>
<h2 id="项目结构-1"><a class="header" href="#项目结构-1">项目结构</a></h2>
<p>一个最基础的pivot lang项目由一个配置文件和一个源文件组成。配置文件用于指定项目的一些基本信息，源文件用于编写pivot lang代码。其结构如下：</p>
<pre><code>.
├── Kagari.toml
└── main.pi
</code></pre>
<h3 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h3>
<p>一个pl项目的根目录必须有一个名为<code>Kagari.toml</code>的配置文件。示例配置文件的内容如下：</p>
<pre><code class="language-toml">entry = &quot;main.pi&quot;
project = &quot;main&quot;
</code></pre>
<p>entry指定了该项目的入口文件，即编译器将从该文件开始编译。如果缺少该配置<code>plc</code>将无法编译该项目</p>
<h3 id="源文件"><a class="header" href="#源文件">源文件</a></h3>
<p>示例项目中的<code>main.pi</code>为源文件。其内容如下：</p>
<pre><code class="language-pl">use std::io;
pub fn main() i64 {
    io::printi64ln(666);
    return 0;
}

</code></pre>
<p>源文件的后缀名必须为<code>.pi</code>。<br />
在示例中，我们调用了一个系统库重的函数<code>printi64ln</code>，该函数用于打印一个i64类型的值并换行。此源代码编译后执行会输出<code>666</code>。</p>
<blockquote>
<p>重要：<code>printi64ln</code>函数是目前pl runtime中的一个测试用内置函数，此函数可能会在未来移除</p>
</blockquote>
<h2 id="编译"><a class="header" href="#编译">编译</a></h2>
<p>如果你已经安装了<code>plc</code>，那么你可以在项目根目录下执行<code>plc main.pi</code>命令来编译该项目。此指令会生成一个名叫<code>out.bc</code>的文件，还有一些中间文件</p>
<blockquote>
<p>如果你配置了静态编译环境，还会生成一个叫做<code>out</code>的文件，该文件是一个可执行文件，可以直接运行
而如果你只有jit环境，该文件不会生成，并且编译命令会输出一个clang报错和两行warning，这是正常现象</p>
</blockquote>
<h2 id="jit运行"><a class="header" href="#jit运行">jit运行</a></h2>
<p>编译后输入<code>plc run out.bc</code>可以jit运行该项目，其输出结果如下：</p>
<pre><code>666
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-support"><a class="header" href="#visual-studio-code-support">Visual Studio Code support</a></h1>
<p>我们建议开发者使用Visual Studio Code作为开发工具，因为我们提供了丰富的插件支持。</p>
<h2 id="vsc插件安装"><a class="header" href="#vsc插件安装">vsc插件安装</a></h2>
<p>在vsc插件市场搜索<code>pivot-lang support</code>，安装第一个即可
<img src="tutorial/2022-10-23-00-17-08.png" alt="" /></p>
<blockquote>
<p>注意：pivot-lang support插件依赖于plc命令，你必须确保plc文件安装路径在环境变量<code>PATH</code>中</p>
</blockquote>
<h2 id="支持功能"><a class="header" href="#支持功能">支持功能</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
vsc debug
<ul>
<li><input disabled="" type="checkbox" checked=""/>
断点</li>
<li><input disabled="" type="checkbox" checked=""/>
变量表
<ul>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
代码高亮</li>
<li><input disabled="" type="checkbox" checked=""/>
lsp支持
<ul>
<li><input disabled="" type="checkbox" checked=""/>
错误容忍
<ul>
<li><input disabled="" type="checkbox" checked=""/>
parser错误容忍</li>
<li><input disabled="" type="checkbox" checked=""/>
ast错误容忍</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
代码提示
<ul>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
函数</li>
<li><input disabled="" type="checkbox" checked=""/>
类型</li>
<li><input disabled="" type="checkbox" checked=""/>
模块</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
代码跳转
<ul>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
函数</li>
<li><input disabled="" type="checkbox" checked=""/>
类型</li>
<li><input disabled="" type="checkbox"/>
模块</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
引用查找
<ul>
<li><input disabled="" type="checkbox" checked=""/>
普通变量</li>
<li><input disabled="" type="checkbox" checked=""/>
函数参数</li>
<li><input disabled="" type="checkbox" checked=""/>
函数</li>
<li><input disabled="" type="checkbox" checked=""/>
类型</li>
<li><input disabled="" type="checkbox"/>
模块</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
语法高亮</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>语言功能的参考文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<p>模块化</p>
<h2 id="模块的划分和使用"><a class="header" href="#模块的划分和使用">模块的划分和使用</a></h2>
<p>总体来说，pl的模块化与rust类似，但是规则比rust简单。<br />
任何一个pl文件都是一个模块，模块的名字就是文件名。一个pl项目的根目录一定有<code>Kagari.toml</code>配置文件，之后所有该项目
模块的路径都是从该文件所在的目录开始计算的。</p>
<p>举个例子，如果我的pl项目有以下的目录结构：</p>
<pre><code class="language-text">test
├── Kagari.toml
├── mod1.pi
├── main.pi
└── sub
    └── mod.pi

</code></pre>
<p>如果<code>main.pi</code>想使用<code>mod1.pi</code>或者<code>mod.pi</code>中的函数，那么可以这样写：</p>
<pre><code class="language-pivot-lang">use mod1;
use sub::mod;

fn main() void {
    mod1::func();
    mod::func();
    return;
}
</code></pre>
<p>如果<code>mod.pi</code>想使用<code>mod1.pi</code>中的函数，那么可以这样写：</p>
<pre><code class="language-pivot-lang">use mod1;

fn main() void {
    mod1::func();
    return;
}

</code></pre>
<blockquote>
<p>！！！目前，pl的模块<strong>不支持</strong>循环引用，循环引用可能导致lsp崩溃。</p>
</blockquote>
<blockquote>
<p>！！！目前pl引入的所有模块必须对应到相对的pi文件（不能对应目录，也不能单独引入函数），而且不能引入同名的模块。</p>
</blockquote>
<h2 id="引用另一个pl项目"><a class="header" href="#引用另一个pl项目">引用另一个pl项目</a></h2>
<p>目前只支持引用本地的pl项目，引用的方式是在<code>Kagari.toml</code>中添加<code>[deps]</code> </p>
<pre><code class="language-toml">[deps]
sub3 = { path = &quot;sub2&quot; }
</code></pre>
<p>使用时，引用的项目模块会在<code>deps</code>中定义的命名空间之下：</p>
<pre><code class="language-pivot-lang">use sub3::lib;

fn main() void {
    lib::func();
    return;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method"><a class="header" href="#method">Method</a></h1>
<p>method就是隶属于某个结构体的函数，它们与普通函数<strong>没有</strong>本质区别。<br />
所有的method都必须在impl块里声明，且method都会隐式的有个<code>self</code>参数，该参数是<code>impl</code>类型的指针 </p>
<blockquote>
<p>为什么pivot-lang的receiver是隐式的？因为我们有gc，所以没必要像rust那样显示的声明receiver类型，统一指针就可以解决几乎所有情况。</p>
</blockquote>
<blockquote>
<p>可能存在的问题：不方便约束receiver不可变的情况</p>
</blockquote>
<h2 id="method-example"><a class="header" href="#method-example">Method Example</a></h2>
<p>最简单的添加method的例子：</p>
<pre><code class="language-pivot-lang">impl impl_struct {
    pub fn add1() void {
        self.x = self.x + 1;
        return;
    }

    pub fn set(x: i64) void {
        self.x = x;
        return;
    }

}

</code></pre>
<p>在一个包中，可以定义外部引入的包中结构体的<code>method</code> . </p>
<p>调用method的时候，使用<code>&lt;receiver类型&gt;.&lt;method&gt;</code>即可 </p>
<pre><code class="language-pivot-lang">let a = A{};
a.method();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface"><a class="header" href="#interface">Interface</a></h1>
<p>接口设计</p>
<h2 id="底层"><a class="header" href="#底层">底层</a></h2>
<p>接口底层实现为结构体，具有如下的结构：</p>
<pre><code>类型哈希
---
原值指针
---
方法1指针
---
方法2指针
---
。。。
---
方法n指针
</code></pre>
<p>对应pltype使用<code>PLTrait</code>，其实内部存储的是结构体类型<code>STType</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pivot-lang-immix-gc"><a class="header" href="#pivot-lang-immix-gc">pivot-lang immix gc</a></h1>
<p>本文档将会描述pl使用的immix gc的一些实现细节与对外接口</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-note"></a></p>
</div>
<div>
<p>此页面仍在编写中，内容可能有疏漏</p>
</div>
</div>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="references/immix.html#overview">Overview</a></li>
<li><a href="references/immix.html#general-description">General Description</a></li>
<li><a href="references/immix.html#allocation">Allocation</a>
<ul>
<li><a href="references/immix.html#global-allocator">Global Allocator</a></li>
<li><a href="references/immix.html#thread-local-allocator">Thread Local Allocator</a></li>
</ul>
</li>
<li><a href="references/immix.html#mark">Mark</a></li>
<li><a href="references/immix.html#sweep">Sweep</a>
<ul>
<li><a href="references/immix.html#%E5%9B%9E%E6%94%B6block">回收block</a></li>
<li><a href="references/immix.html#%E4%BF%AE%E6%AD%A3line-header">修正line header</a></li>
<li><a href="references/immix.html#%E8%AE%A1%E7%AE%97evacuation%E4%BF%A1%E6%81%AF">计算evacuation信息</a></li>
</ul>
</li>
<li><a href="references/immix.html#evacuation">Evacuation</a></li>
<li><a href="references/immix.html#%E6%80%A7%E8%83%BD">性能</a></li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>此gc是我们基于<a href="https://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf">immix gc论文</a>实现的，
大部分的实现细节都与论文一致，对于一些论文没提到的细节我们自行进行了实现，参考了很多别的gc项目。该gc是一个支持多线程使用的、
基于shadow stack的，精确mark-region 非并发（Concurrency） 并行（Parallelism） gc。</p>
<div id="admonition-gc的并发concurrency与并行parallelism" class="admonition tip">
<div class="admonition-title">
<p>gc的并发（Concurrency）与并行（Parallelism）</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-gc的并发concurrency与并行parallelism"></a></p>
</div>
<div>
<p>gc中并发和并行是两个不同的术语，并发gc指的是能够在应用不暂停的基础上进行回收的gc，
而并行gc指的是gc在回收的时候能够使用多个线程同时进行工作。一个gc可以既是并行的也是并发的，
我们的immix gc目前只具备并行能力</p>
</div>
</div>
这里有一些创建该gc过程中我们主要参考的资料，列表如下：  
<ul>
<li><a href="https://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf">immix gc论文</a></li>
<li><a href="https://github.com/playXE/libimmixcons">playxe 的 immixcons（immix gc的一个rust实现，回收存在bug）-- 很多底层内存相关代码是参考该gc完成的，还有在函数头中加入自定义遍历函数的做法</a></li>
<li><a href="https://github.com/scala-native/immix">给scala-native使用的一个immix gc的C实现</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/immix/">康奈尔大学CS6120课程关于immix gc的博客，可以帮助快速理解论文的基本思路</a></li>
</ul>
<h2 id="general-description"><a class="header" href="#general-description">General Description</a></h2>
<p>本gc是为pl <strong>定制的</strong>，虽然理论上能被其他项目使用，但是对外部项目的支持<strong>并不是主要目标</strong></p>
<p>pl的组件包含一个全局的<code>GlobalAllocator</code>，然后每个<code>mutator</code>线程会包含一个独属于该线程的<code>Collector</code>，每个<code>Collector</code>中包含一个
<code>ThreadLocalAllocator</code>。在线程使用gc相关功能的时候，该线程对应的<code>Collector</code>会自动被创建，直到线程结束或者
用户手动调用销毁api。</p>
<div id="admonition-部分immix-gc术语介绍" class="admonition tip">
<div class="admonition-title">
<p>部分immix gc术语介绍</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-部分immix-gc术语介绍"></a></p>
</div>
<div>
<p><strong>mutator</strong></p>
<p>mutator指使用gc的用户程序，在有些文档里也被指代为gc的client</p>
<p><strong>block</strong></p>
<p>block是immix中全局分配器分配的基础单位，每个block的大小为32KB</p>
<p><strong>line</strong></p>
<p>line是block中的基本单位，每个line长度为128B，每个block中包含256个line</p>
<p><strong>Global Allocator</strong></p>
<p>全局分配器，简称GA，分配内存以block为单位</p>
<p><strong>Thread Local Allocator</strong></p>
<p>线程本地分配器，简称TLA，分配内存以line为单位，在自身的block中分配，如果没有可用的block，会向全局分配器申请</p>
<p><strong>Collector</strong></p>
<p>线程本地的回收器，在每次gc开始的时候会运行标记和驱逐算法，然后通知Thread Local Allocator进行清扫</p>
<p><strong>Evacuation</strong></p>
<p>驱逐算法，是一种反碎片化机制</p>
</div>
</div>
<p>下方是使用immix gc的应用程序的工作流程图：</p>
<pre class="mermaid">graph LR;
    subgraph Program
        style Collector1 fill:#b4b2e6
        style Collector2 fill:#b4b2e6
        direction TB
        subgraph Immix GC
            direction TB
            GA
            Collector1
            Collector2
        end
        GA[Global Allocator]--give blocks--&gt;TLA1;
        TLA1-.return free blocks.-&gt;GA;
        subgraph Collector1
            direction TB
            TLA1[Thread Local Alloctor]
            Marker1[Marker]
        end
        GA--give blocks--&gt;TLA2;
        TLA2-.return free blocks.-&gt;GA;
        subgraph Collector2
            direction TB
            TLA2[Thread Local Alloctor]
            Marker2[Marker]
        end
        subgraph Mutator
            direction TB
            Thread1
            Thread2
        end
        TLA1--lines--&gt;Thread1
        TLA2--lines--&gt;Thread2
        Marker1-.Mark, evacuate.-&gt;TLA1
        Marker2-.Mark, evacuate.-&gt;TLA2
    end

</pre>
<p>Immix GC由于分配以line为单位，在内存利用率上稍有不足，但是其算法保证了极其优秀的内存局部性，配合TLA、GA的设计也大大
减少了线程间的竞争。</p>
<h2 id="allocation"><a class="header" href="#allocation">Allocation</a></h2>
<h3 id="global-allocator"><a class="header" href="#global-allocator">Global Allocator</a></h3>
<p>GA是全局的，一个应用程序中只会有一个，负责分配block。在GA被初始化的时候，会向操作系统申请一大
块连续的内存，然后将其切分为block，每个block的大小为32KB。GA有一个<code>current</code>指针，指向
目前GA分配到的位置。当GA需要分配新block的时候，GA会返回当前<code>current</code>指针指向的内存空间，
并且将<code>current</code>指针向后移动一个block的距离。</p>
<p>GA同时维护一个<code>free</code>动态数组，用于存储已经被回收的block，当GA需要分配新block的时候，会先从<code>free</code>数组中
尝试取出一个block，如果<code>free</code>数组为空，才会分配新的block。</p>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-info"></a></p>
</div>
<div>
<p>潜在的优化点：使用bitmap来记录block的使用情况，这样可以减少动态数组的开销</p>
</div>
</div>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-warning"></a></p>
</div>
<div>
<p>如果GA在分配新block的时候，发现<code>current</code>指针已经超出了初始申请的内存空间，会导致程序panic。这个行为应该在未来被改善</p>
</div>
</div>
<h3 id="thread-local-allocator"><a class="header" href="#thread-local-allocator">Thread Local Allocator</a></h3>
<p>TLA是线程本地的，每个线程都会有一个TLA，负责分配line，和进行sweep回收。</p>
<div id="admonition-部分tla用到的术语介绍" class="admonition tip">
<div class="admonition-title">
<p>部分TLA用到的术语介绍</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-部分tla用到的术语介绍"></a></p>
</div>
<div>
<ul>
<li>小对象：小于line size的对象</li>
<li>中对象：大于line size，小于block size/4（8KB）的对象</li>
<li>大对象：大于block size/4的对象</li>
<li>hole：block中一个未被使用的连续空间称之为hole</li>
</ul>
</div>
</div>
<p>在每次回收的时候，TLA会将所有完全空闲的block回收给GA，所有部分空闲的block会被加入到<code>recycle</code>数组中，在之后的分配里被重复利用。
所有完全被占用的block会被加入到<code>unavailable</code>数组中，不会被重复利用。</p>
<p>TLA的小对象分配策略如下：</p>
<center>
<pre class="mermaid">graph TD;
    A[分配内存]--&gt;B{有recycle block?}
    B--是--&gt;C[从recycle block中分配line]
    B--否--&gt;D{申请新block}
    D--成功--&gt;E[新block加入recycle block]
    D--失败--&gt;I[panic]
    E--&gt;C
    C--&gt;F{block用完?}
    F--是--&gt;G[移入unavailable block]
    F--否--&gt;H[返回分配空间的指针]
    G--&gt;H
</pre>
</center>
<div id="admonition-中对象大对象分配策略" class="admonition note">
<div class="admonition-title">
<p>中对象、大对象分配策略</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-中对象大对象分配策略"></a></p>
</div>
<div>
<p>中对象存在一个问题，就是如果他采用小对象的分配策略，在recycle block中分配line，那么分配过程中可能跳过
很多的小hole，而TLA的分配器在recycle block中分配的时候是<strong>不回头</strong>的，这样可能会导致：</p>
<ul>
<li>内存碎片增加</li>
<li>分配时间变长</li>
</ul>
<p>因此，中对象分配的时候只会找recycle block中的第一个hole，如果这个hole装不下它，TLA会直接申请新的block来分配该对象，
并且将这个block加入到recycle block中。</p>
<p>大对象分配不使用mark region算法，它使用特殊的bigobject allocator来分配，是传统的mark free算法。</p>
<p>因为程序中小对象的数量远远大于中对象和大对象，所以TLA的分配器会优先优化小对象分配，以增加性能</p>
</div>
</div>
<h2 id="mark"><a class="header" href="#mark">Mark</a></h2>
<p>Mark阶段的主要工作是标记所有被使用的line和block，以便在后续的sweep阶段进行回收。我们的mark算法是<strong>精确</strong>的，
这点对evacuation算法的实现至关重要。</p>
<p>精确GC有两个要求：</p>
<ul>
<li>root的精确定位</li>
<li>对象的精确遍历</li>
</ul>
<p>我们的精确root定位是基于<strong>Stack Map</strong>的，这部分细节过于复杂，将在<a href="references/stackmap.html">单独的文档</a>中介绍。</p>
<p>对象的精确遍历是通过编译器支持实现的，plimmix将所有heap对象分类为以下4种：</p>
<ul>
<li>Atomic Object：原子对象，不包含指针的对象，如整数、浮点数、字符串等</li>
<li>Pointer Object：指针对象，该对象本身是一个指针</li>
<li>Complex Object：复杂对象，该对象可能包含指针</li>
<li>Trait Object：Trait对象，该对象包含一个指针，在他的offset为8的位置，这个类型是专门配合pivot lang的trait设计的，是个特殊优化</li>
</ul>
<p>对于Atomic Object，我们不需要遍历，因为他们不包含指针。</p>
<p>对于Pointer Object，我们只需要遍历他们的指针即可。</p>
<p>对于Complex Object，编译器需要在对象开始位置增加一个<code>vtable</code>字段，该字段的值指向该类型的遍历函数。此遍历函数由编译器生成，
其签名为：</p>
<pre><code class="language-rust ignore">pub type VisitFunc = unsafe fn(&amp;Collector, *mut u8);
// vtable的签名，第一个函数是mark_ptr，第二个函数是mark_complex，第三个函数是mark_trait
pub type VtableFunc = fn(*mut u8, &amp;Collector, VisitFunc, VisitFunc, VisitFunc);</code></pre>
<p>在标记的时候，我们会调用对象的vtable对他进行遍历</p>
<p>对于Trait Object，我们需要遍历他指向实际值的指针</p>
<p>下方是一个immix heap的示意图，其中<code>*</code>表示该对象会在mark阶段中被标记</p>
<pre class="mermaid">graph LR;
    subgraph Stack
        Root1
        Root2
        Root3
        Root4
    end
    subgraph HO[Heap]
        AtomicObject1[AtomicObject1*]
        AtomicObject2[AtomicObject2*]
        AtomicObject3
        PointerObject1[PointerObject1*]
        PointerObject2[PointerObject2*]
        ComplexObject1
    end
    subgraph ComplexObject1[ComplexObject1*]
        VT1[VTable]
        PF1[PointerField]
        AF1[AtomicField]
        ComplexField
    end
    subgraph ComplexField
        VT2[VTable]
        AF2[AtomicField]
        PF2[PointerField]
    end
    PF1 --&gt; PointerObject1
    PF2 --&gt; AtomicObject2
    PointerObject1 --&gt; AtomicObject1
    PointerObject2 --&gt; ComplexObject1
    Root1 --&gt; PointerObject1
    Root2 --&gt; PointerObject2
    Root3 --&gt; PointerObject1

</pre>
<p>对于<code>ComplexObject1</code>，他的vtable函数逻辑如下：</p>
<pre><code class="language-rust ignore">fn vtable_complex_obj1(&amp;self, mark_ptr: VisitFunc, mark_complex: VisitFunc, mark_trait: VisitFunc){
    mark_ptr(self.PointerField)
    mark_complex(self.ComplexField)
}</code></pre>
<p>而对于<code>ComplexField</code>，他的vtable函数逻辑如下：</p>
<pre><code class="language-rust ignore">fn vtable_complex_field(&amp;self, mark_ptr: VisitFunc, mark_complex: VisitFunc, mark_trait: VisitFunc){
    mark_ptr(self.PointerField)
}</code></pre>
<p>实际上，<code>mark_complex</code>和<code>mark_trait</code>逻辑都十分简单：<code>mark_complex</code>只是调用对象的vtable函数，而
<code>mark_trait</code>只是对实际指针调用<code>mark_ptr</code>，真正的标记和驱逐逻辑都在<code>mark_ptr</code>中实现。</p>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-tip"></a></p>
</div>
<div>
<p>标记过程开始的时候，gc会load所有root指向的值，对他们调用<code>mark_ptr</code>，如果该值为gc堆中的对象，
则会将该对象标记，并且再次load它指向的对象，若该对象非AtomicObject类型则加入到mark queue中。</p>
<p>在mark queue中的对象，会被逐个取出，根据他们的类型对他们调用<code>mark_ptr</code>、<code>mark_complex</code>或者<code>mark_trait</code>，直到
mark queue为空，则标记过程结束。</p>
<p>尽管这的确可以看作是一个递归的过程，但是此过程一定不能使用递归的方式实现，因为递归的方式在复杂程序中可能会导致栈溢出。</p>
</div>
</div>
<h2 id="sweep"><a class="header" href="#sweep">Sweep</a></h2>
<p>Sweep阶段的主要工作是：</p>
<ul>
<li>回收所有未被标记的block</li>
<li>修正所有line的header</li>
<li>计算evacuation需要的一些信息</li>
</ul>
<h3 id="回收block"><a class="header" href="#回收block">回收block</a></h3>
<p>回收block的过程非常简单，我们只需要遍历所有的block，如果block的header中的<code>mark</code>字段为<code>false</code>，则将该block回收，统一返回给GA</p>
<h3 id="修正line-header"><a class="header" href="#修正line-header">修正line header</a></h3>
<p>如果一个block被mark了，那么需要对block中的所有lineheader根据line是否被标记
进行修正。</p>
<h3 id="计算evacuation信息"><a class="header" href="#计算evacuation信息">计算evacuation信息</a></h3>
<p>计算一个<code>mark</code>数组，该数组中下标为idx的元素值表示hole数量为idx的所有block的marked line的数量</p>
<h2 id="evacuation"><a class="header" href="#evacuation">Evacuation</a></h2>
<p>每次回收开始之前，我们会先判断是否需要进行反碎片化，目前的策略是只要recycle block&gt;1就进行反碎片化。</p>
<div id="admonition-info-1" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-info-1"></a></p>
</div>
<div>
<p>优化点：如果处于内存用尽的紧急情况也应当进行evacuation，且threshold应当设置的更低</p>
</div>
</div>
<p>如果决定了需要进行反碎片化，那么我们会构建一个<code>available</code>数组，该数组中下标为idx的元素值表示hole数量为idx的所有block的可用line的数量，
然后我们按照洞的数量从大到小遍历<code>available</code>和<code>mark</code>数组，会定义一个<code>required</code>值，该值在每次遍历的时候加上<code>mark</code>数组中的值，
减去<code>available</code>数组中的值，如果某次循环后<code>required</code>值小于0，那么当前循环对应的hole数量+1就是我们evacuate的阈值（threshold）。
在此之后根据<code>threshole</code>将所有洞数量大于等于<code>threshole</code>的block标记为待evacuate。</p>
<p>真正的evacuation过程是在<code>mark</code>阶段一起完成的，我们会在遍历到处于待evacuate的block中的对象时，为它分配一个新的地址，并且
将它原地址的值替换为一个指向新地址的指针（forward pointer），且将line header中的<code>forward</code>字段设置为<code>true</code>。之后如果再次遍历到
该对象，收集器会修正指向原地址的指针的值，这一过程我们称之为自愈。该过程如下图所示</p>
<pre class="mermaid">graph TD;
    subgraph BeforeEva
        direction TB
        EvaBlock
        EmptyBlock
        Pointer
    end
    subgraph EvaBlock
        Line1
        Line2
        LineK[...]
        LineN
    end
    subgraph Line1
        Addr[addr: 0x1000]
        Value[value: 0x4321]
        Forward[forward: false]
    end
    subgraph EmptyBlock
        EL1
        ELK[...]
    end
    subgraph EL1[Line1]
        AddrEL[addr: 0x2000]
        ValueEL[value: 0x0000]
    end
    Pointer
    Pointer--&gt;Line1
    subgraph AfterEva
        direction TB
        EvaBlock1
        EmptyBlock1
        Pointer1[Pointer]
    end
    subgraph EvaBlock1[EvaBlock]
        Line11
        Line21[Line2]
        LineK1[...]
        LineN1[LineN]
    end
    subgraph Line11[Line1]
        Addr1[addr: 0x1000]
        Value1[value: 0x2000]
        Forward1[forward: true]
    end
    subgraph EmptyBlock1[EmptyBlock]
        EL11
        ELK1[...]
    end
    subgraph EL11[Line1]
        AddrEL1[addr: 0x2000]
        ValueEL1[value: 0x4321]
    end
    Pointer1--&gt;EL11
    BeforeEva--&gt;AfterEva

</pre>
<p>每次驱逐是以分配的对象为单位，如果一个block被标记为待evacuate，那么在驱逐过程中，该block中的所有对象都一定会被驱逐。</p>
<p>请注意，一部分其他gc的驱逐算法中的自愈需要读写屏障的参与，immix不需要。这带来了较大的mutator性能提升。</p>
<div id="admonition-warning-1" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-warning-1"></a></p>
</div>
<div>
<p>驱逐算法的正确性建立在我们的root定位和对象遍历的正确性之上，如果root定位和对象遍历不精确，
建议禁用驱逐算法。这二者的不精确会导致驱逐算法修改的指针不能完全自愈。考虑下方场景：</p>
<pre>
<code class="language-rust ignore hljs">
struct Node {
    next: *mut Node,
    data: u32,
}

fn main() {
    let mut root = Node {
        next: null_mut(),
        data: 0,
    };
    let stack_ptr = &mut root as * mut u8;
    add_root(stack_ptr);
}

fn add_sub_ndoe(root: *mut Node) {
    let mut node = Node {
        next: null_mut(),
        data: 0,
    };
    root.next = &mut node;
}</code>
</pre>
<p>在这个例子中，我们只添加了一个root即<code>main</code>中的<code>root</code>变量，尽管<code>add_sub_node</code>中的<code>node</code>变量和<code>root</code>参数也是root，
但是不添加它们其实不会影响大部分gc在这个例子中的正确性。然而如果启用了驱逐算法，这个例子就很可能在运行时出错。
假如<code>add_sub_node</code>函数中触发了gc，且gc决定进行驱逐，将<code>main</code>函数中的<code>root</code>变量移动到了新的地址，那么在gc过程中
<code>stackptr</code>对应的指针指向的位置会自愈，更改为移动后的地址，但是<code>add_sub_node</code>函数中的<code>root</code>参数因为没被添加到root set中，
这导致gc无法在回收过程中对其进行修正，就会进一步导致<code>root.next</code>指向的地址不正确，从而导致程序出错。</p>
</div>
</div>
<div id="admonition-多线程情况下驱逐算法的安全性" class="admonition tip">
<div class="admonition-title">
<p>多线程情况下驱逐算法的安全性</p>
<p><a class="admonition-anchor-link" href="references/immix.html#admonition-多线程情况下驱逐算法的安全性"></a></p>
</div>
<div>
<p>在多线程情况下，是存在两个线程同时驱逐一个对象的可能的，在这种情况下一些同步操作必不可少，但是并不需要加锁。
我们通过一个cas操作来保证只有一个线程能够成功驱逐该对象。</p>
</div>
</div>
<h2 id="性能"><a class="header" href="#性能">性能</a></h2>
<p>我们与bdwgc进行了很多比较，数据证明在大多数情况下，我们的分配算法略慢于bdwgc，与malloc速度相当，但是在回收的时候，我们的回收速度要快于bdwgc。
对于一些复杂的测试，在触发回收的策略相同的情况下，我们的单线程总执行时间略慢于bdwgc，但是在多线程情况下，我们的总执行时间明显快于bdwgc，
整体来说机器并行能力越强、测试时使用内存越多immix性能优势越大。</p>
<p>使用github action进行的基准测试结果可以在<a href="https://chronostasys.github.io/bdwgcvsimmix-bench/report/">这里</a>查看，由于github action使用的机器
只有两个核心，所以测试线程数量为2，在此结果中，可以看到immix整体性能略差于bdwgc，但是差距小于单线程情况。</p>
<p>你可以从<a href="https://github.com/Chronostasys/bdwgcvsimmix-bench">这里</a>下载测试代码，在你的机器上运行并进行比较。这里我提供一组笔者机器上的测试数据截图</p>
<p><img src="references/immix.png" alt="" /></p>
<p><img src="references/bdw.png" alt="" /></p>
<p>测试环境为MacBook Pro (16-inch, 2021) Apple M1 Pro 16 GB，可以看出immix在此环境中已经具有近4倍的性能优势。</p>
<p>immix作为天生并发的gc，并发情况下几乎能完全避免锁竞争的出现，因此在多线程情况下的性能优势是非常明显的。并且其分配算法很好的维护了空间局部性，理论上
能带来更好的mutator性能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stak-map"><a class="header" href="#stak-map">Stak Map</a></h1>
<ul>
<li><a href="references/stackmap.html#introduction">Introduction</a></li>
<li><a href="references/stackmap.html#%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0">细节实现</a>
<ul>
<li><a href="references/stackmap.html#stackmap%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F">stackmap格式和读取方式</a></li>
<li><a href="references/stackmap.html#%E5%9F%BA%E4%BA%8Estackmap%E7%9A%84%E7%B2%BE%E7%A1%AEroot%E5%AE%9A%E4%BD%8D%E5%AE%9E%E7%8E%B0">基于stackmap的精确root定位实现</a></li>
</ul>
</li>
<li><a href="references/stackmap.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>stackmap是一种用于实现精确gc的机制，简单来说它会在编译期间根据编译器提供的信息在编译后的目标文件
中插入栈变量的位置信息，这样在运行时gc扫描栈时就可以根据这些信息来确定栈上的变量的位置，从而完成精确回收。</p>
<p>stackmap方式的精确回收相比shadow stack的方式有以下优点：</p>
<ul>
<li>无需维护gcroot链表，减少了开销</li>
<li>避免了运行时调用维护gcroot链表的函数形成的开销</li>
</ul>
<p>但是同时它也有以下缺点：</p>
<ul>
<li>跨平台存在劣势，各个平台的栈结构和可执行文件结构都有差异，stackmap过于底层，跨平台很复杂</li>
<li>stackmap在回收的时候需要遍历函数调用栈，遍历栈的跨平台实现也很复杂，而且很多现有库都有bug</li>
</ul>
<p>我们的stackmap功能基于llvm提供的一系列gc相关功能实现，llvm在这方面的文档十分混乱差劲，
甚至官网文档代码有一部分无法编译，还有很多地方严重过时与实际情况不符，因此全网都难找到基于llvm
实现stackmap功能的代码。本文档会尽量对这些部分进行说明。</p>
<h2 id="细节实现"><a class="header" href="#细节实现">细节实现</a></h2>
<h3 id="stackmap格式和读取方式"><a class="header" href="#stackmap格式和读取方式">stackmap格式和读取方式</a></h3>
<p>llvm提供了一系列的gc相关api，首先是gc策略，我们可以给每个函数指定一个gc策略，并且llvm内置了一些gc策略。</p>
<p>为了性能和方便考虑，我们的gc实现了自己的gc策略（plimmix），此策略通过一个自定义llvm插件实现。其代码在 <strong>immix/llvm</strong> 目录下
两个C文件一个定义了我们的GC策略，一个定义了我们的stackmap格式和生成方式。</p>
<p>我们的stackmap格式如下：</p>
<pre><code>Header {
  i64  : Stack Map Version (current version is 1)
  i32  : function 数量
}
// 这里要对齐
Functions[NumFunctions] {
  u64 : Function Address
  i32 : Stack Size（单位是8字节）
  i32 : 需要压栈的函数变量数量（不同平台不一样，大部分平台前6个参数会用寄存器传）
  i32 : root数量
  i32 : safe point数量
  SafePoints[NumSafePoints] {
    u64: 地址
  }
  Roots[NumRoots] {
    i32: root的偏移(相对栈指针)
    i32: root的类型
  }
}
Global {
  i32: global root数量
  // 对齐
  Roots[NumRoots] {
    u64 : 地址
  }
}
</code></pre>
<pre class="mermaid">graph LR;
    subgraph Front[编译器前端]
        A[插入gcroot指令]
        B[生成stackmap初始化代码]
        A--&gt;B
    end
    B--&gt;C
    subgraph Back[LLVM]
        C[目标代码生成]
        D[生成原始stackmap数据]
        C--&gt;D
    end
    D--&gt;E
    subgraph Plugin[Immix 插件]
        E[生成stackmap]
        F[写入目标代码数据段]
        E--&gt;F
    end

    
</pre>
<div id="admonition-gc-safepoint介绍" class="admonition tip">
<div class="admonition-title">
<p>gc safepoint介绍</p>
<p><a class="admonition-anchor-link" href="references/stackmap.html#admonition-gc-safepoint介绍"></a></p>
</div>
<div>
<p>safepoint是潜在的可以触发gc的点位，本来多用于进行多线程回收的同步：大部分gc
回收算法在回收时（全部或一部分时间）是不允许mutator运行的，这个时候需要暂停所有mutator
线程（stop the world），等回收完成后再恢复。使用safepoint机制的gc，在mutator线程运行到safepoint时会对
一个特殊flag进行检查，以判断自己是否需要暂停进行gc。在我们的immix gc中，
safepoint通常由其中一个工作线程在自己的safepoint发起，别的线程到达自己的下一个safepoint是会随即暂停，等到所有线程
都暂停的时候再进行回收。我们的safepoint目前是在所有malloc点位，不过我们的llvm插件目前会将所有函数调用点位都当作
safepoint处理。</p>
<p>safepoint对于stackmap至关重要，因为在回收时gc就是通过在stackmap中查询当前暂停对应的safepoint地址来获取当前栈中的root集的。在暂停的时候safepoint地址在当前栈帧的ip寄存器中。</p>
<p>由于gc回收需要等待所有线程到达safepoint，所以如果一个线程长期不到达safepoint，别的线程在回收的时候就可能会一直等待。因此
immix提供一些工具函数。<code>thread_stuck_start</code>和<code>thread_stuck_end</code>，用于标记线程在执行某些长时间“卡住”的任务，在此期间
该线程需要保证不会使用gc分配新的内存，否则可能导致内存安全问题。在线程被标记为stuck的阶段触发的gc会跳过同步该线程。<code>no_gc_thread</code>
可以告知gc目前正在执行的线程不需要gc功能，该线程不会分配对应的ThreadLocalAllocator。</p>
</div>
</div>
<p>我们的llvm插件会将stackmap信息生成到每个目标文件的数据段中，应用程序可以使用weak link的方式用对应的全局变量获取到这个数据标签对应的地址，然后就可以通过这个地址来获取到stackmap信息了。对应数据区域标签的命名规则是：<code>_GC_MAP_$source_file_name</code>，其中<code>$source_file_name</code>是对应llvm module中记录的的源文件名。</p>
<p>stackmap有多种读取方式，下方是我们使用的方式：</p>
<p>immix gc提供了<code>gc_init</code>函数，该函数接受一个stackmap指针，会加载该stackmap。我们的编译器
会在编译的时候为每个模块生成一个初始化stackmap的函数，该函数以一定的规则命名，之后
在生成主模块的的时候会自动在main函数开始处对这些初始化函数进行调用。</p>
<p>这部分代码理论上可以通过llvm插件自动完成，这部分以后应该会进行实现。实现此功能之后，我们的immix gc将会成为可以方便的给任何基于llvm的语言接入的gc。</p>
<p><code>gc_init</code>函数主要会读取stackmap中的数据并且进行遍历，之后生成一个哈希表，用于快速的查找对应的safepoint地址。这个哈希表的key是safepoint地址，value是safepoint所在
函数的所有gcroot信息。</p>
<h3 id="基于stackmap的精确root定位实现"><a class="header" href="#基于stackmap的精确root定位实现">基于stackmap的精确root定位实现</a></h3>
<p>为了遍历函数调用栈，我们使用<code>backtrace.rs</code>包，该包封装了一些平台相关的函数调用栈遍历的实现。</p>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="references/stackmap.html#admonition-warning"></a></p>
</div>
<div>
<p>栈爬取的实现不同平台差异巨大，很容易出现bug。目前我们发现在mac aarch64上如果使用lld进行链接会导致该backtrace包出现
segment fault，这个问题目前使用ld替代lld进行规避。</p>
</div>
</div>
<p>遍历的时候通过<code>backtrace.rs</code>拿到当前ip寄存器的值，然后去我们构建的stackmap中查找到当前函数栈的root进行遍历，遍历完成后继续向上层函数栈遍历。
注意这里遍历的起点不在mutator代码中，而在gc代码中，所以遍历的开头和结尾查不到对应记录是完全正常的。</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="references/stackmap.html#admonition-note"></a></p>
</div>
<div>
<p>潜在优化点：其实从gc的函数到目标语言最底层函数的调用栈层数在运行时是固定的，所以这里其实可以优化，跳过前几个栈帧，直接从目标语言最底层函数开始遍历。</p>
</div>
</div>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li><a href="https://llvm.org/docs/StackMaps.html">llvm stackmap 文档</a></li>
<li><a href="https://llvm.org/docs/GarbageCollection.html">llvm gc 文档</a></li>
<li><a href="https://github.com/KavinduZoysa/test-GCs">读取llvm默认生成的stackmap例子</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler"><a class="header" href="#compiler">Compiler</a></h1>
<p>pivot-lang编译器（以下简称编译器）主要由三个部分组成：nom分析器、ast和llvm后端。</p>
<h2 id="nom-parser"><a class="header" href="#nom-parser">Nom parser</a></h2>
<p>nom parser包含了编译器的词法分析和语法分析部分。nom parser的主要功能是使用递归下降法将pivot-lang源代码转换为ast。</p>
<h2 id="ast"><a class="header" href="#ast">AST</a></h2>
<p>AST是抽象语法树的简称，是编译器的中间表示。AST是由nom parser生成的，它是一个树形结构，每个节点都是一个结构体，包含了节点的类型、子节点、行号、列号等信息。</p>
<h2 id="llvm-backend"><a class="header" href="#llvm-backend">LLVM backend</a></h2>
<p>本编译器使用llvm来生成目标代码，llvm的jit部分会被包含在我们的编译器可执行文件中，然而静态编译不行。因此静态编译相比jit会多一个llvm的依赖。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser">Parser</a></h1>
<p>parser源代码位置位于<code>src/nomparser</code>目录下，包含了词法分析和语法分析部分。</p>
<h2 id="nom"><a class="header" href="#nom">nom</a></h2>
<p><a href="https://github.com/Geal/nom">nom</a>是一个用rust编写的parser combinator库，它不像lr分析器一样提供生成代码的功能，而是
提供一组函数，这些函数可以用来组合出各种parser。</p>
<p>相比于lr分析器，nom的优点是它的parser combinator非常灵活，熟练后可以快速组合出各种parser，
而且可自定义性非常的强，看起来也很直观，相比很多ir生成器的语法并没有复杂多少，但是带来了更好的
语法支持（一般的ir分析生成器的语法定义文件不会有编程语言那么好的语法支持）。</p>
<p>会使用nom是读懂编译器parser代码的重要前提，这里强烈推荐两个nom文档：</p>
<ul>
<li><a href="https://github.com/Geal/nom/blob/main/doc/nom_recipes.md">Nom Recipes</a></li>
<li><a href="https://github.com/Geal/nom/blob/main/doc/choosing_a_combinator.md">choosing a combinator</a></li>
</ul>
<h2 id="parser结构"><a class="header" href="#parser结构">parser结构</a></h2>
<p>parser的主要功能是使用递归下降法将pivot-lang源代码转换为ast。如果你不了解递归下降法，可以先看看<a href="https://ruslanspivak.com/lsbasi-part1/">这篇文章</a>。</p>
<p>对于pivot lang的每一条语法规则，都会在parser里对应一个分析函数，这些分析函数可能会调用其他分析函数，最终最上层的分析函数可以将完整的源代码转换为ast。</p>
<p>pivot lang的完整语法规则见<a href="compiler/../../../#grammar">这里</a></p>
<p>parser最顶层的函数是<code>parse</code>，它接受一个源文件输出一个AST根节点。</p>
<pre><code class="language-rust no_run noplayground">#[salsa::tracked]
pub fn parse(db: &amp;dyn Db, source: SourceProgram) -&gt; Result&lt;ProgramNodeWrapper, String&gt; {
    let text = source.text(db);
    let re = program(Span::new_extra(text, false));
    if let Err(e) = re {
        return Err(format!(&quot;{:?}&quot;, e));
    }
    let (_, node) = re.unwrap();
    log::info!(&quot;parse {:?}&quot;, source.path(db));
    Ok(ProgramNodeWrapper::new(db, node))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-1"><a class="header" href="#ast-1">AST</a></h1>
<p>抽象语法树是目前编译器中最复杂的部分，它是编译器的中间表示，也是编译器的核心。本节将介绍AST的设计和实现。</p>
<h2 id="ast的设计"><a class="header" href="#ast的设计">AST的设计</a></h2>
<p>基本上，所有源代码中的基础单位都会对应抽象语法树中的一个节点。抽象语法树有很多类型的节点，他们可能会相互引用。</p>
<p>所有的节点都必须实现<code>Node</code> trait，这个trait定义了节点的基本行为。</p>
<pre><code class="language-rust no_run noplayground">#[enum_dispatch]
pub trait Node: RangeTrait + FmtTrait + PrintTrait {
    fn emit&lt;'a, 'ctx, 'b&gt;(
        &amp;mut self,
        ctx: &amp;'b mut Ctx&lt;'a&gt;,
        builder: &amp;'b BuilderEnum&lt;'a, 'ctx&gt;,
    ) -&gt; NodeResult;
}

#[enum_dispatch]
pub trait PrintTrait {
    fn print(&amp;self, tabs: usize, end: bool, line: Vec&lt;bool&gt;);
}
</code></pre>
<p>你可能注意到了，<code>Node</code>trait继承了<code>RangeTrait</code>，这个trait定义了节点的位置信息。</p>
<pre><code class="language-rust no_run noplayground">#[enum_dispatch]
pub trait RangeTrait {
    fn range(&amp;self) -&gt; Range;
}</code></pre>
<p>一般来说，<code>RangeTrait</code>的实现通过<code>#[range]</code>宏来自动生成，你不需要手动实现它。</p>
<p><code>Node</code>接口中的<code>print</code>函数用于打印节点的信息，它会被用于调试。<code>print</code>打印的结果和<code>tree</code>的输出非常像，你需要用一些工具函数来
格式化输出。以<code>ifnode</code>的<code>print</code>函数为例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn print(&amp;self, tabs: usize, end: bool, mut line: Vec&lt;bool&gt;) {
        deal_line(tabs, &amp;mut line, end);
        tab(tabs, line.clone(), end);
        println!(&quot;IfNode&quot;);
        self.cond.print(tabs + 1, false, line.clone());
        if let Some(el) = &amp;self.els {
            self.then.print(tabs + 1, false, line.clone());
            el.print(tabs + 1, true, line.clone());
        } else {
            self.then.print(tabs + 1, true, line.clone());
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>emit</code>函数是生成llvm代码的核心，它会调用llvm api构造自己对应的llvm ir。在编译的时候，最上层节点的<code>emit</code>会被调用，
该函数会递归的调用自己的子节点的<code>emit</code>函数，最终生成整个程序的llvm ir。<br />
下方是<code>ifnode</code>的<code>emit</code>函数：</p>
<pre><code class="language-rust no_run noplayground">    fn emit&lt;'a, 'ctx, 'b&gt;(
        &amp;mut self,
        ctx: &amp;'b mut Ctx&lt;'a&gt;,
        builder: &amp;'b BuilderEnum&lt;'a, 'ctx&gt;,
    ) -&gt; NodeResult {
        let cond_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.cond&quot;);
        let then_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.then&quot;);
        let else_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.else&quot;);
        let after_block = builder.append_basic_block(ctx.function.unwrap(), &quot;if.after&quot;);
        builder.build_unconditional_branch(cond_block);
        ctx.position_at_end(cond_block, builder);
        let condrange = self.cond.range();
        let (cond, pltype, _) = self.cond.emit(ctx, builder)?;
        if pltype.is_none() || !pltype.clone().unwrap().borrow().is(&amp;PriType::BOOL) {
            return Err(ctx.add_diag(
                condrange
                    .new_err(ErrorCode::IF_CONDITION_MUST_BE_BOOL)
                    .add_help(&quot;use a bool variable instead&quot;)
                    .clone(),
            ));
        }
        let (cond, _) = ctx.try_load2var(condrange, cond.unwrap(), pltype.unwrap(), builder)?;
        let cond = builder.build_int_truncate(cond, &amp;PriType::BOOL, &quot;trunctemp&quot;);
        builder.build_conditional_branch(cond, then_block, else_block);
        // then block
        ctx.position_at_end(then_block, builder);
        let (_, _, then_terminator) = self.then.emit_child(ctx, builder)?;
        if then_terminator.is_none() {
            builder.build_unconditional_branch(after_block);
        }
        ctx.position_at_end(else_block, builder);
        let terminator = if let Some(el) = &amp;mut self.els {
            let mut child = ctx.new_child(el.range().start, builder);
            let (_, _, else_terminator) = el.emit(&amp;mut child, builder)?;
            if else_terminator.is_none() {
                builder.build_unconditional_branch(after_block);
            }
            if then_terminator.is_return() &amp;&amp; else_terminator.is_return() {
                TerminatorEnum::RETURN
            } else {
                TerminatorEnum::NONE
            }
        } else {
            builder.build_unconditional_branch(after_block);
            TerminatorEnum::NONE
        };
        ctx.position_at_end(after_block, builder);
        if terminator.is_return() {
            builder.build_unconditional_branch(after_block);
        }
        ctx.emit_comment_highlight(&amp;self.comments[0]);
        Ok((None, None, terminator))
    }</code></pre>
<p>emit函数的参数是节点自身，第二个参数是编译上下文。编译上下文中会包含一些需要透传的信息，比如符号表，llvmbuilder，lsp参数等。</p>
<h2 id="打印ast结构"><a class="header" href="#打印ast结构">打印AST结构</a></h2>
<p>plc命令行工具有打印ast的功能，你可以使用<code>plc xxx.pi --printast</code>命令来打印ast结构。<br />
下方是一个ast打印结果的样例：</p>
<pre><code class="language-ast">...
file: /Users/bobli/src/pivot-lang/test/sub/mod.pi
ProgramNode
 └─ FuncDefNode
     ├─ id: name
     ├─ TypeNameNode
     │   └─ ExternIdNode
     │       └─ VarNode: void
     └─ StatementsNode
         └─ RetNode
file: /Users/bobli/src/pivot-lang/test/mod2.pi
ProgramNode
 ├─ UseNode
 │   ├─ VarNode: sub
 │   └─ VarNode: mod
 ├─ FuncDefNode
 │   ├─ id: test_mod
 │   ├─ TypedIdentifierNode
 │   │   ├─ id: args
 │   │   └─ TypeNameNode
 │   │       └─ ExternIdNode
 │   │           └─ VarNode: i64
 │   ├─ TypeNameNode
 │   │   └─ ExternIdNode
 │   │       └─ VarNode: void
 │   └─ StatementsNode
 │       └─ RetNode
 └─ StructDefNode
     ├─ id: Mod2
     └─ TypedIdentifierNode
         ├─ id: y
         └─ TypeNameNode
             └─ ExternIdNode
                 └─ VarNode: bool
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-chart"><a class="header" href="#flow-chart">Flow Chart</a></h1>
<p>这是一个附加功能，它将为每个函数生成流程图，以 <code>.dot</code> 文件格式输出，<code>.dot</code> 文件可通过</p>
<ul>
<li><a href="https://graphviz.org/">Graphviz</a></li>
<li><a href="https://dreampuf.github.io/GraphvizOnline">Graphviz Online</a></li>
</ul>
<p>查看。</p>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<ul>
<li><a href="https://github.com/petgraph/petgraph">petgraph</a></li>
</ul>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>流程图的生成包含两个步骤：</p>
<ul>
<li>由 AST 生成 <code>图</code> 数据结构</li>
<li>根据 <code>图</code> 生成 <code>.dot文件</code></li>
</ul>
<h3 id="图的生成"><a class="header" href="#图的生成">图的生成</a></h3>
<p>我们以函数为单位生成 <code>graph</code> ，而 AST 根节点为 <code>ProgramNode</code>，因此我们需要遍历其 <code>fntypes</code>
，逐个生成 <code>graph</code> 最终得到一个 <code>Vec</code> ：</p>
<pre><code class="language-rust no_run noplayground">impl ProgramNode {
   pub fn create_graphs(&amp;self) -&gt; Vec&lt;GraphWrapper&gt; {
       let mut graphs = vec![];
       for func in &amp;self.fntypes {
           if let Some(body) = func.body.clone() {
               let graph = from_ast(Box::new(NodeEnum::STS(body)));
               graphs.push(GraphWrapper {
                   name: func
                       .id
                       .name
                       .clone()
                       .replace(|c: char| !c.is_ascii_alphanumeric(), &quot;_&quot;),
                   graph,
               });
           }
       }
       graphs
   }
}</code></pre>
<p>接下来实现 <code>from_ast()</code> 函数，它接收一个 <code>NodeEnum</code>（这是一个 <code>Statements</code> 节点）， 返回一个完整的 <code>Graph</code>，具体分为两步：</p>
<ul>
<li>初步构建图(<code>build_graph()</code>)</li>
<li>去除不必要节点(<code>0入度节点</code>,<code>虚节点</code>,<code>空节点</code>))</li>
</ul>
<pre><code class="language-rust no_run noplayground">pub fn from_ast(ast: Box&lt;NodeEnum&gt;) -&gt; Graph {
   let mut ctx = GraphContext::new();
   build_graph(ast, &amp;mut ctx);
   // 删除入度为 0 的节点
   while remove_zero_in_degree_nodes(&amp;mut ctx.graph) {}
   // 删除虚节点
   while remove_single_node(&amp;mut ctx.graph, |_, t| *t == GraphNodeType::Dummy) {}
   // 删除空节点
   let remove_empty_nodes: fn(NodeIndex, &amp;GraphNodeType) -&gt; bool = |_, t| match t {
       GraphNodeType::Node(t) =&gt; t.is_empty() || t.trim() == &quot;;&quot;,
       _ =&gt; false,
   };
   while remove_single_node(&amp;mut ctx.graph, remove_empty_nodes) {}
   ctx.graph
}</code></pre>
<p>主要介绍构建图的环节。</p>
<p>定义图的 <code>节点</code> 与 <code>边</code> ：</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, PartialEq)]
pub enum GraphNodeType {
   Dummy,               // 虚节点
   Begin,               // 起点
   End,                 // 终点
   Node(String),        // 普通节点
   Err(String, String), // 错误节点
   Choice(String),      // 选择节点
}

#[derive(Debug, Clone, Copy)]
pub enum EdgeType {
   Normal,
   Branch(bool), // 分支，带有 Y/N 等标签
}

pub type Graph = StableDiGraph&lt;GraphNodeType, EdgeType&gt;;</code></pre>
<p><code>build_graph()</code>函数以 <code>Statement</code> 为单位，针对不同节点构建不同的图结构，为了方便的连接节点，我们定义了 <code>GraphContext</code> 用于存储上下文信息:</p>
<pre><code class="language-rust no_run noplayground">struct GraphContext {
   pub graph: Graph,
   pub break_target: NodeIndex,
   pub continue_target: NodeIndex,
   #[allow(dead_code)]
   pub global_begin: NodeIndex, // 全图起点
   pub global_end: NodeIndex,   // 全图终点
   pub local_source: NodeIndex, // 局部起点
   pub local_sink: NodeIndex,   // 局部终点
}</code></pre>
<p>每次调用 <code>build_graph()</code> 前，我们需要为构建部分提供两个 <code>锚点(local_source, local_sink)</code> ，第一次调用时，<code>锚点</code> 即为起点和终点，
以后每次调用前，均需构建两个虚节点，作为<code>锚点</code>(虚节点之后将被去掉)。</p>
<p>对于不涉及分支、循环、跳转的简单语句，图结构较为简单：</p>
<pre><code>local_source -&gt; current -&gt; local_sink

local_source ------------&gt; local_sink // 注释

local_source ---&gt; ERR ---&gt; local_sink // 错误
</code></pre>
<p>分支及循环语句则较为复杂(以 <code>IF语句</code> 为例)：</p>
<pre><code>IF:                /--Y--&gt; sub_source -----&gt; [...body...] ------&gt; sub_sink -&gt;-\
                  /                                                            \
local_source -&gt; cond                                                        local_sink
                  \                                                           /
                   \--N--&gt; sub_source1 -&gt; Option&lt;[...els...]&gt; -&gt; sub_sink -&gt;-/

</code></pre>
<p><code>if.body</code> 及 <code>if.els</code> 部分可以通过递归调用 <code>build_graph()</code> 构建，但是需要先生成两个虚节点，并<strong>暂时</strong>赋给 <code>ctx</code>，构建完毕后，
<code>ctx</code> 的 <code>local_source/sink</code>需要还原</p>
<p>对于语句块，对每个语句调用 <code>build_graph()</code> ，每次将 <code>sub_source</code> 更改为 <code>sub_sink</code> ，<code>sub_sink</code> 则重新创建：</p>
<pre><code class="language-rust no_run noplayground">               for i in &amp;v.statements {
                   context.local_source = sub_source;
                   context.local_sink = sub_sink;
                   build_graph(i.clone(), context);
                   if i != v.statements.last().unwrap() {
                       sub_source = sub_sink;
                       sub_sink = context.graph.add_node(GraphNodeType::Dummy);
                   }
               }</code></pre>
<h3 id="dot-文件生成"><a class="header" href="#dot-文件生成">.dot 文件生成</a></h3>
<p>我们只需按dot语法格式生成图的点/边的信息即可。下面是一个简单的dot文件：</p>
<pre><code>digraph _pointer_struct__name_params {
    D0 [shape=box, style=rounded, label=&quot;begin&quot;, fontname=&quot;&quot;];
    {rank = sink; D1 [shape=box, style=rounded, label=&quot;end&quot;, fontname=&quot;&quot;];}
    D4 [shape=box, label=&quot;return\l&quot;, fontname=&quot;&quot;];
    D4 -&gt; D1;
    D0 -&gt; D4;
}
</code></pre>
<p>可以在<a href="https://dreampuf.github.io/GraphvizOnline">Graphviz Online</a>查看对应流程图。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-server"><a class="header" href="#language-server">Language Server</a></h1>
<p>Pivot Lang的Language Server（以下简称LSP）是一个用于为编译器提供语法支持的组件，它同时被用于在编译期间生成诊断信息。</p>
<blockquote>
<p>基本上，lsp能够为所有的现代代码编辑器提供服务，但是目前我们只为vsc提供官方支持。如果想在别的编辑器中使用lsp，可能需要自己写一个
简单的客户端插件。</p>
</blockquote>
<h3 id="注意事项"><a class="header" href="#注意事项">⚠️注意事项</a></h3>
<p><strong>有一些函数功能纯粹，可能被用在很多无法预料的地方，如果在这些函数中操作非幂等的lsp相关功能很可能导致lsp最后工作时出现错误，请尽量避免</strong>！</p>
<p>目前大部分lsp的功能接口都是幂等的。<code>semantic_token</code>和<code>doc_symbol</code>不幂等</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计design"><a class="header" href="#设计design">设计(design)</a></h1>
<p>pivot-lang的lsp功能被内置于编译器中，它是以差量计算（incremental）为前提设计的。
目前整个lsp程序几乎是完全单线程的，但得益于我们的差量计算，它仍然具有不错的性能。</p>
<h2 id="1-差量计算incremental"><a class="header" href="#1-差量计算incremental">1. 差量计算(incremental)</a></h2>
<p>差量计算是指在编译器中，当源代码发生修改时，我们只对发生变化的部分进行重新分析，而不是对整个项目全部重新进行计算。</p>
<p>pivot-lang的差量计算是基于rust的<a href="https://github.com/salsa-rs/salsa">salsa</a>库实现的。
我们使用的版本是仍然处于预览阶段的<code>salsa_2022</code>。</p>
<p>pl中的差量计算的最小复用单元是<code>Module</code>，即一个源文件。</p>
<p>在plc作为lsp运行时，所有的lsp功能相关计算会在<code>TextDocumentEdit</code>事件发生时进行，之后如果不进行文本编辑，所有的
lsp请求都会直接从缓存中读取结果。</p>
<h2 id="2-差量计算举例"><a class="header" href="#2-差量计算举例">2. 差量计算举例</a></h2>
<p>假设我们有一个pl项目，其中有三个文件：<code>a.pi</code>、<code>b.pi</code>、<code>c.pi</code>。
其中<code>a.pi</code>和<code>b.pi</code>都引用了<code>c.pi</code>中的函数<code>f</code>，并且<code>a.pi</code>中还使用了<code>b.pi</code>中的函数<code>g</code>。</p>
<p>此时，当我们用vsc打开此pl项目，vsc会启动plc进行分析。如果没使用差量计算，那么plc分析流程如下：</p>
<pre><code>尝试分析a.pi-&gt;
依赖c.pi-&gt;
分析c.pi-&gt;
返回继续分析a.pi-&gt;
依赖b.pi-&gt;
分析b.pi-&gt;
依赖c.pi-&gt;
分析c.pi-&gt;
返回继续分析b.pi-&gt;
返回继续分析a.pi-&gt;
完成
</code></pre>
<p>可以看到<code>c.pi</code>被分析了两次，这是不必要的。差量分析在这一步中可以优化掉第二次对<code>c.pi</code>的分析。</p>
<p>然后，假设我们在<code>a.pi</code>中添加了一个字符，那么如果没采用差量分析法，所有的模块都会被重新分析一遍。而差量分析法只会对<code>a.pi</code>进行重新分析。</p>
<p>接着，如果我们改动了<code>b.pi</code>，那么差量分析法会对<code>b.pi</code>和<code>a.pi</code>进行重新分析，而不会对<code>c.pi</code>进行重新分析。<strong>即：每次修改文件时，只会对该文件以及依赖该文件的文件进行重新分析。</strong></p>
<h2 id="3-验证差量计算是否正常工作"><a class="header" href="#3-验证差量计算是否正常工作">3. 验证差量计算是否正常工作</a></h2>
<p>我们可以在vsc的选项中找到一个plc的<code>Log Level</code>选项，将它设置成<code>2</code>之后就能看到plc的<code>info</code>日志了。<br />
<img src="lsp/2022-12-08-13-20-37.png" alt="" /></p>
<blockquote>
<p>日志可以在vsc的outut中选择<code>pivot-lang language server</code>查看
<img src="lsp/2022-12-08-13-22-04.png" alt="" /></p>
</blockquote>
<p>这里会在每次重新计算的时候输出对应的log。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diagnostic"><a class="header" href="#diagnostic">Diagnostic</a></h1>
<p>诊断信息是个非常重要的功能，它可以帮助我们在编写代码的时候发现错误和可能有问题的地方，从而提高我们的编码效率。</p>
<p>为了让用户体验尽可能的好，我们的lsp分析需要尽量容忍用户的错误输入，尽可能多的分析出用户代码中的问题</p>
<h2 id="fault-tolerance"><a class="header" href="#fault-tolerance">Fault Tolerance</a></h2>
<p>错误容忍是生成好的诊断信息的前提。在pivot-lang的中，我们分别在两个层面上实现了错误容忍：</p>
<ul>
<li>parser</li>
<li>ast</li>
</ul>
<h3 id="parser的错误容忍"><a class="header" href="#parser的错误容忍">Parser的错误容忍</a></h3>
<p>nom parser架构中，如果出现了一个无法被识别的语句，整个分析器就会终止分析输出错误。这对于错误容忍的要求来说是无法被接受的。所以
我们的编译器不使用nom parser的默认错误处理机制，任何parser阶段产生的nom error都应该被视作<strong>bug</strong>，我们应该尽可能的避免这种情况。</p>
<p>在parse过程中，如果一些错误语句能非常明显的被识别为一个语法的未完成项（且没有歧义），我们应该将它识别为该语法类型的Node，并且在Node上加一个
flag标识它不完整（常常是<code>is_complete</code>），这样在ast阶段我们就能输出对应的诊断信息。</p>
<p>对于最常见的基础语法单位<code>statement</code>和<code>top_statement</code>，parser提供了一个helper函数<code>except</code>，能够在遇到不可被识别的错误语句的时候
将该“块”语句识别为<code>ErrNode</code>，以方便后续的分析正常进行。</p>
<blockquote>
<p>！！！<strong>注意</strong>：ErrNode虽然很好用，但是它只能输出很宽泛的诊断信息（比如无法识别该语句），它是最后的错误容忍手段，应该尽量避免使用它</p>
</blockquote>
<h3 id="ast的错误容忍"><a class="header" href="#ast的错误容忍">AST的错误容忍</a></h3>
<p>由于parse阶段的时候能够容忍错误的语句，对于一些语法错误，ast节点只需要检查自身的完整性就能够输出诊断信息了。而对于语义错误（例如类型不匹配），我们需要在ast阶段
进行分析并获取结果。这些操作目前是在各个节点的<code>emit</code>函数里进行的。所有的<code>emit</code>函数都返回<code>NodeResult</code>类型，如果该节点的<code>emit</code>中出现了错误，
分析将会中断，其对应的错误信息会被添加到<code>ctx</code>（编译上下文）中并且作为<code>error</code>返回。上层函数如果遇到自己依赖的函数报错<strong>一定不能重复添加该错误至<code>ctx</code>中</strong>，
否则会导致错误信息重复输出。上层函数处理自己的依赖报错有两种情况：</p>
<ul>
<li>直接停止分析并将该错误传递给自己的上级</li>
<li>忽略该错误继续进行分析</li>
</ul>
<p>一般来说，大部分的expression和statement都会采用第一种方案，而statement block则会采用第二种方案</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemlib"><a class="header" href="#systemlib">SystemLib</a></h1>
<p>pl的系统库一部分是pl代码一部分是rust代码，rust部分在项目的<code>vm</code>目录中，pl部分在<code>planglib</code>目录中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm"><a class="header" href="#vm">VM</a></h1>
<p>放rust写的给pivot-lang使用的函数</p>
<p>所有导出的函数需要加<code>#[is_runtime]</code>，所有导出结构体需要加<code>#[repr(C)]</code></p>
<h2 id="jit-invalid-memory-access-issue"><a class="header" href="#jit-invalid-memory-access-issue">JIT invalid memory access issue</a></h2>
<p>在jit模式下使用runtime函数可能会出现<code>invalid memory access</code>错误，
这个问题本质是rust编译的时候会优化掉不使用的module，导致jit时找不到对应runtime函数。所以建议每个
mod加一个叫做<code>reg</code>的函数，里边<strong>必须用到你会使用的所有结构体</strong>，这样在需要jit测试的时候调用使用模块的<code>reg</code>函数，对应代码就不会被优化掉了。</p>
<h2 id="使用is_runtime导出rust函数"><a class="header" href="#使用is_runtime导出rust函数">使用<code>is_runtime</code>导出rust函数</a></h2>
<p>一个被<code>is_runtime</code>标记的rust函数在编译到静态库之后，在pivot-lang中声明对应的函数，即可像正常函数一样调用。例如：</p>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[is_runtime]
fn printi64ln(i: i64) {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}</span></code></pre></pre>
<p>Pivot Lang:</p>
<pre><code class="language-pivot-lang">fn printi64ln(i: i64) void

fn main() void {
    printi64ln(1)
    return
}
</code></pre>
<blockquote>
<p>！！！<strong>注意事项</strong>：<code>is_runtime</code>标记的函数不能有modifier（比如<code>pub</code>，<code>unsafe</code>），但是被<code>is_runtime</code>标记的<code>impl</code>块中的函数不受此限制。</p>
<pre><code class="language-rust ignore">struct MyStruct;
#[is_runtime(&quot;struct&quot;)]
impl MyStruct {
  pub fn myfunc1() {
      // ...
   }
}</code></pre>
<p>标记impl块时，导出的函数名称会变为<code>{structname}__{fnname}</code>的形式，函数允许使用receiver。更多高级用法参见<code>is_runtime</code>的rust doc</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gc"><a class="header" href="#gc">GC</a></h1>
<blockquote>
<p>！WIP：此页面描述的功能仍然在实验性阶段，可能有些细节没有实现完毕。</p>
</blockquote>
<p>pivot-lang 是一门使用gc进行内存管理的语言。</p>
<p>pivot-lang 的gc目前是使用rust写的，采用一种叫做<code>immix</code>[[1]](https://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf)的mark region算法。</p>
<p>在以前的版本中，我们使用的是我们现在叫做<code>simple gc</code>的垃圾回收算法，他是一个简单的mark-sweep算法。
它由于性能问题和不支持多线程等原因最终被<code>immix</code>取代。不过我们仍然保留了它的代码，并且设置了一个编译开关（<em>feature:simple_gc</em>），可以在编译时手动选择使用该gc算法。</p>
<h2 id="simple-gc"><a class="header" href="#simple-gc">Simple GC</a></h2>
<p>simple gc就和他的名字一样，<a href="https://github.com/Pivot-Studio/pivot-lang/blob/master/vm/src/gc/_simple_gc.rs">代码</a>十分简单（算法实现大概100行）。它没有自己的allocator，直接
使用C中的<code>malloc</code>和<code>free</code>进行内存分配和释放。</p>
<p>simple gc是一个<a href="https://www.cs.cornell.edu/courses/cs6120/2020fa/blog/modern-gc/">保守gc算法(Conservative Garbage Collection)</a>，它没有能力精确的分辨出哪些内存是指针，哪些不是。因此它会试图将所有的内存都当做指针来处理。</p>
<p>目前simple gc不建议在生产环境中使用，其代码保留下来是为了方便我们在未来的版本中进行性能对比，以及为未来用于教育目的做准备。</p>
<h2 id="immix-gc"><a class="header" href="#immix-gc">Immix GC</a></h2>
<p>immix gc是一种mark region算法，它是一个精确的gc算法。但是请注意，它的精确建立在使用它
的项目提供的特殊支持之上。可以认为目前我们的immix gc实现 <strong>是为pivot-lang量身定制</strong> 的。pl编译器为了和我们的immix gc配合，会在编译时专门生成一些额外的代码，如果缺少这些代码，immix gc将无法正常工作。
所以虽然理论上我们可以将我们的immix gc用到其他项目中，这么做的效益很可能并不是很高--
缺少编译器的支持，使用者将需要手动添加那些额外的代码。</p>
<p>immix gc的实现代码在<a href="https://github.com/Pivot-Studio/pivot-lang/blob/master/immix">这里</a>。它是天生支持多线程使用的，但是我们的pivot-lang目前还不支持多线程。</p>
<h3 id="目前存在的一些问题"><a class="header" href="#目前存在的一些问题">目前存在的一些问题</a></h3>
<p>!!!NEED HELP!!!</p>
<p>似乎在windows上性能明显差于linux和mac，但是说实话我并不是这方面的专家，如果有大佬了解这方面欢迎帮我吗优化。</p>
<h2 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h2>
<p>我们对两种gc算法进行了一些基准测试，事实证明immix gc的回收性能要比simple gc <strong>快近20倍</strong>。如果你对这些测试感兴趣，可以在项目根目录运行<code>make bench</code>查看immix的benchmark，或者运行<code>make bench-simple-gc</code>查看simple gc的benchmark。</p>
<p>下方分别是simple gc和immix gc的benchmark结果，测试于2023年1月，commit 62b5c52c01e8133f5300e33a0131a50ba0c8d0de</p>
<p><img src="systemlib/2023-01-24-23-23-55.png" alt="" /></p>
<p><img src="systemlib/2023-01-24-23-25-06.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planglib"><a class="header" href="#planglib">planglib</a></h1>
<p>planglib目录下的每一个文件夹都是一个系统模块，在编译的时候会自动被加入依赖中，不需要在配置文件中特殊配置。</p>
<h2 id="planglib如何在编译期间被找到"><a class="header" href="#planglib如何在编译期间被找到">planglib如何在编译期间被找到</a></h2>
<p>plc编译器在编译时会试图寻找<code>KAGARI_LIB_ROOT</code>环境变量，并且将该变量视为<code>planglib</code>的根目录</p>
<blockquote>
<p>不设置或错误设置<code>KAGARI_LIB_ROOT</code>环境变量可能导致无法进行编译或者代码分析</p>
</blockquote>
<p>如果你是plang开发者，你可以手动在<code>~/.bashrc</code>或者<code>~/.bash_profile</code>中加入以下代码：</p>
<pre><code class="language-bash">export KAGARI_LIB_ROOT=&lt;pivot-lang project path&gt;/planglib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为pivot-lang贡献代码"><a class="header" href="#为pivot-lang贡献代码">为Pivot Lang贡献代码</a></h1>
<p>非常感谢您愿意对本项目提供帮助！</p>
<p>下方是对您为 <a href="https://github.com/Pivot-Studio/pivot-lang">pivot-lang</a> 贡献代码的一些帮助</p>
<p>如果您刚开始了解pivot-lang项目，可以加入我们的社区 <a href="https://jq.qq.com/?_wv=1027&amp;k=I5vdShVl">qq 群</a> 向我们提问.</p>
<p><strong>因为本项目还处于早期阶段</strong>: 本页面的指导很可能会在未来有更改，欢迎帮助我们改进此页面！</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<h3 id="开源协议"><a class="header" href="#开源协议">开源协议</a></h3>
<p>本项目使用 <a href="https://opensource.org/licenses/MIT">MIT</a> 协议。对本项目贡献代码即表示您同意您的更改遵守该协议。</p>
<h2 id="您能做的事情"><a class="header" href="#您能做的事情">您能做的事情</a></h2>
<h3 id="issues"><a class="header" href="#issues">Issues</a></h3>
<p>我们有很多的已有的issue，在添加新功能的时候我们也会添加相关的issue。如果您发现我们的bug或者有什么需求，欢迎新建 <a href="https://github.com/Pivot-Studio/pivot-lang/issues">issues</a> 
来告诉我们。您也可以看一些 <a href="https://github.com/Pivot-Studio/pivot-lang/issues?q=is%3Aopen+is%3Aissue">open</a> 的issue并且参与讨论或者贡献代码帮助修复它。</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>非常欢迎帮助我们实现新功能。我们的新功能实现分为几个阶段：</p>
<ul>
<li>提出，讨论需求的合理性和必要性</li>
<li>讨论实现方案</li>
<li>实现</li>
<li>reveiew</li>
<li>合并</li>
</ul>
<p>一些简单的需求可以跳过第二个阶段，所有超过第一个阶段的需求都会被放在我们的<a href="https://github.com/orgs/Pivot-Studio/projects/7/views/1">project</a>中。如果您想帮助实现
已有需求，请去此页面寻找处于new或者ready状态的项目。如果您想实现一个新的需求，请先在<a href="https://github.com/Pivot-Studio/pivot-lang/issues">issues</a>中提出，最好加入
<a href="https://jq.qq.com/?_wv=1027&amp;k=I5vdShVl">qq群</a> 和我们一起讨论方案，在讨论决定通过后，我们会在<a href="https://github.com/orgs/Pivot-Studio/projects/7/views/1">project</a>中添加一个新的对应项目。</p>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<p>强烈建议在提交修改的时候同时添加对应的测试，帮助我们将测试覆盖率保持在 <strong>85%</strong>, 帮助我们进一步完善测试也是相当欢迎的。</p>
<p>请在提交pr前确认自己的修改能通过所有的测试(通过运行 <code>cargo test --all</code>)</p>
<h3 id="benchmark-1"><a class="header" href="#benchmark-1">Benchmark</a></h3>
<p>目前我们还没有基准测试，欢迎帮助我们添加基准测试。</p>
<h3 id="文档"><a class="header" href="#文档">文档</a></h3>
<p>参见 <a href="https://lang.pivotstudio.cn/">文档</a> 网站。对应源码在 <a href="https://github.com/Pivot-Studio/pivot-lang/tree/master/book">book</a> 目录中，欢迎帮助我们完善文档。</p>
<h2 id="风格"><a class="header" href="#风格">风格</a></h2>
<h3 id="issue-风格"><a class="header" href="#issue-风格">Issue 风格</a></h3>
<p>请在提出issue时提供至少三个小自然段的说明，包括：你想干什么，遇到了什么问题，如果复现这个问题等。</p>
<p>如果可能的话，希望您能提供:</p>
<ul>
<li>如歌是在使用的时候遇到的bug，最好有一小段代码或者一个指向 <a href="https://gist.github.com">gist</a> 的链接，其中包含能复现问题的代码。</li>
<li>完整的 backtrace, 如果是进程崩溃相关的问题。</li>
<li>一个示例项目，如果是编译相关的问题。</li>
</ul>
<h3 id="代码风格"><a class="header" href="#代码风格">代码风格</a></h3>
<p>rust代码风格通过使用 <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> 进行统一 
请尽量减少代码重复率，增加可读性。</p>
<p>为了避免不同的rust小版本格式化的区别，请使用以下命令格式化: <code>cargo +stable fmt</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聊一聊pivot-lang"><a class="header" href="#聊一聊pivot-lang">聊一聊pivot-lang</a></h1>
<p>这是这个项目的第一篇博客，这篇博客里我准备讲一讲这个项目的意义还有它的发展方向，还有一些写的过程中的有趣的话题。</p>
<p>这个项目希望创造出一种好用的类rust的新编程语言，他要具有大部分先进的特性，并且避免掉rust太难学习的缺点。</p>
<p>目前已经完成的部分和rust非常的像，但是已经有一些功能上出现区别，比如模块化。模块化表面上和rust有点像，但是其实完全不一样，要说类似其实反而和go更类似一些，不过也有很大区别。<br />
我们预计之后的一些高级功能，比如代数类型、模式匹配和一些别的特殊语法糖上，我们会和rust有巨大分歧，这方面还敬请期待。</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>项目大概是2022年9月中旬开始的，一开始的时候我们几乎完全手写了第一版lexer和parser。当时那一部分代码大部分是<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>写的，因为我那个时候还不会rust，只能对<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>的代码进行拙劣的模仿。我们初期争论比较大的点是是否该用lr分析法的工具，而不是ll分析手写递归下降。最后我们还是觉得ll可控性更好一些，选择了手写。但是就写了个开头，我们就发现这玩意写到后边可维护性会有很大问题，简直是依托__。</p>
<p>所以我们开始重新考虑一些自动或者半自动的工具，比如antlr、lalrpop之类的。这些工具有个很严重的问题，就是他们往往需要在特殊格式里编写一部分源代码，而写这部分代码的时候是没有代码提示的。这对于其他的语言应该好一些，但是这对于rust来说是相当致命的，尤其是在我们没有人是rust大佬的情况下。</p>
<p>这个时候伟大的<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>找到了<a href="https://github.com/Geal/nom">nom</a>，虽然这个东西上手有点不习惯，但是熟练之后被证明究极好用，于是我们果断重写了之前的lexer和parser的代码。我代码量大概就是这个时候开始反超<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>的，因为重构几乎都是我搞的。</p>
<p>之后我们十一之前加班加点，希望在10.1期间作出一个有一些基础功能的版本，这期间有很多人都参与了代码编写，不过总体来说这一阶段的工作是比较简单的。唯一一个相对难一点的功能是@CjiW做的函数相关的功能，函数至今也是我们代码生成中最复杂的模块之一。</p>
<p>十一之后我们加入了大量lsp相关的功能，还有debug支持。这两个都是之前我做的项目中比较少或者没有涉及过的，意外的是这两个功能的实现都比较顺利。</p>
<p>顺带一提，项目里很多奇怪的东西还有一些文件的命名多少沾点二次元，这都是托了<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>大爷的福。</p>
<p>再后来，我们的高级功能开始提上日程，<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>几乎实现了泛型功能的所有代码，这部分逻辑十分复杂，因为涉及到自动泛型推断和代码膨胀等技术，是目前编译器中最复杂的功能之一。谢谢你，<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>!</p>
<p>顺便提一句，<a href="https://github.com/RINNE-TAN">@RINNE-TAN</a>现在是单身，如果有人对找程序员男朋友感兴趣，请抓紧</p>
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<p>接下来一段时间的首要任务是完善泛型功能，让impl快能加泛型，接口也支持泛型。然后，就是代数类型和模式匹配，这些任务预计寒假能搞完。之后的高级功能就是闭包和协程支持，然后需要完善系统库，gc支持多线程。如果非常顺利的话，寒假结束前有机会完成到协程。<br />
项目现在非常缺人，如果你对开发pl感兴趣，请联系我们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码分析和差量计算"><a class="header" href="#代码分析和差量计算">代码分析和差量计算</a></h1>
<p>在<a href="https://lang.pivotstudio.cn/lsp/design.html">lsp的文档</a>中我简单介绍了差量计算在lsp模块中起到的优化作用，这里我将会详细介绍一下这个过程，希望能帮没接触过差量计算的小伙伴了解为何差量计算对于lsp的计算任务来说如此重要，以及什么情况下适合使用差量计算。</p>
<h2 id="纯函数"><a class="header" href="#纯函数">纯函数</a></h2>
<p>差量计算中的基础对象一般是纯函数，纯函数的定义是：对于给定的输入，总是会有相同的输出，而且<strong>不会有任何副作用</strong>。<br />
请注意其中<strong>不会有任何副作用</strong>这一点，如果要建立一个正确工作差量计算模型，必须要保证这一点。</p>
<h3 id="带有副作用的函数为什么会影响差量计算正确性"><a class="header" href="#带有副作用的函数为什么会影响差量计算正确性">带有副作用的函数为什么会影响差量计算正确性？</a></h3>
<p>试想以下场景：我有两个参与差量计算的基础函数<code>A</code>和<code>B</code>，<code>A</code>不是纯函数，它会修改全局变量<code>a</code>，每次运行他会把<code>a</code>加一。
那么在某次计算过程中，<code>A</code>的输入与上次相同，<code>B</code>有变化，这导致<code>B</code>被重新执行了，而<code>A</code>直接使用上次缓存的计算结果，跳过了这次计算。那么这会导致本次计算全局变量<code>a</code>没有被<code>A</code>修改。这导致一个很严重的问题：<strong>即使用差量计算之后相比使用之前，相同情况下计算的影响不一样</strong>。<br />
假设上方例子中不使用差量计算，那么<code>A</code>会被重新执行一次，这样<code>a</code>相比差量计算情况就会被多加一，<strong>正确的差量计算模型不应该对系统状态有影响</strong>，所以如果要使用差量计算，应该保证所有参与计算的函数都是没有副作用的纯函数。</p>
<h3 id="一些容易被忽略的副作用情况"><a class="header" href="#一些容易被忽略的副作用情况">一些容易被忽略的副作用情况</a></h3>
<p>尽管纯函数的定义比较简单，上方的例子也比较直观，但是实际生产中其实很多函数都是有副作用的，而且很多初学者可能并不能完全分析出这些函数
的副作用。这里特别说一个容易被忽略的副作用情况：</p>
<ul>
<li>修改被差量计算框架缓存的函数输出结果</li>
</ul>
<p>在你分析一个函数有没有副作用的时候应该记住：被缓存的纯函数输出也属于全局状态，和全局变量没有本质区别。所以修改这些被缓存值也是有副作用的。修改这些值很可能在无意中发生：比如函数<code>A</code>的输出中有个类型指针，它输出后作为输入传给了函数<code>B</code>，函数<code>B</code>修改了这个类型指针指向的值，这样虽然看起来没有进行和全局变量相关的操作，但是实际上这个类型指针指向的值就是被缓存的函数<code>A</code>的输出，这种行为修改了缓存状态，是有副作用的。</p>
<h2 id="差量计算系统设计原则"><a class="header" href="#差量计算系统设计原则">差量计算系统设计原则</a></h2>
<p>有了上方纯函数相关的知识，我们可以总结出一个正确的差量计算系统需要遵循的两条原则：</p>
<ul>
<li>差量计算系统中，一个函数的输出应该是<strong>只读</strong>的，应该避免在别的函数中修改对应值</li>
<li>差量计算函数不能修改<strong>任何</strong>全局状态</li>
</ul>
<h2 id="实战举例--lsp引用查找功能设计"><a class="header" href="#实战举例--lsp引用查找功能设计">实战举例--lsp引用查找功能设计</a></h2>
<p>lsp引用查找是一个绝大部分语言插件都有的功能，它被使用的也很多，大部分程序员同学应该每天都会用到很多次。这个功能底层实现是比较简单的，如果不考虑差量计算的话：</p>
<blockquote>
<p>在符号表中所有能被引用的符号中多存一个<code>refs</code>链表，每次该符号被使用，往链表中加入被使用的位置。最后在接收到<code>find reference</code>请求的时候，查找到对应的符号，返回<code>refs</code>链表即可。</p>
</blockquote>
<p>但是这么设计在差量计算的时候会遇到问题：假设我们差量计算的最小单位是<code>compile_file</code>函数，它的意义是编译一个文件，那么这个函数输出的编译结果中就应该包含该文件中定义的所有的符号，自然也包括这些符号的<code>refs</code>信息。然而，很多符号是可以被跨文件使用的，比如全局变量，这些符号的<code>refs</code>信息是跨文件的，所以这些符号的<code>refs</code>信息可能会在对别的文件调用<code>compile_file</code>函数时被修改，这样就违反了差量计算系统的第原则：<strong>差量计算函数不能修改任何全局状态</strong>。<br />
如果我们直接用这种设计来进行差量计算的话：</p>
<blockquote>
<p>假设有文件<code>A</code>和文件<code>B</code>，<code>A</code>中有全局变量<code>a</code>，<code>B</code>中使用了全局变量<code>a</code>，第一次编译是全量编译，生成了正确的<code>refs</code>信息。第二次编译的时候，用户只修改了<code>B</code>，所以<code>A</code>的编译被跳过，复用了上次结果。这时请注意：<code>a</code>的<code>refs</code>链表是包含上次编译产生的完整结果的，而不是只有<code>A</code>文件中的引用信息，这一切都是因为<code>B</code>在编译的时候可能改<code>A</code>的编译结果，往<code>a</code>的<code>refs</code>里加值。</p>
</blockquote>
<p>所以我们需要重新设计这个功能，我们需要把<code>refs</code>信息从符号中移除，放到一个与编译文件绑定的<code>refs</code>表中，这个表可以是<code>map[str]vec&lt;Location&gt;</code>类型，他只记录当前文件中符号的引用信息。当lsp收到<code>find reference</code>请求的时候，先找到对应的符号，然后再遍历所有文件的编译输出，找到对应符号在各个<code>refs</code>表中的记录，并且汇总。这样就可以保证差量计算的正确性了。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>我不是很擅长写文章，不知道这篇表达的清不清楚，如果能帮助到你就再好不过了。文章篇幅限制，这篇博客里跳过了差量计算框架的使用细节。
如果你对这方面感兴趣，可以参考我们的<a href="https://github.com/Pivot-Studio/pivot-lang">源代码</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
