use core::panic;
const a = 100;
pub fn true_with_pnanic() bool {
    panic::pl_panic();
    return true;
}

pub struct complex_struct {
    x: i64;
    pub y: *bool;
    pub z: [base * 2];
}

/// struct coment
struct base {
}

/// fn coment
/// fn coment
fn struct_init() void {
    /// comment
    let t = complex_struct{
        x: 1,
        y: &true,
        z: [base{}, base{}]
    };
    t.z[1];
    return;
}

fn ifel() void {
    if true {
    } else {
        if true {
        }
    }
    if true {
    }
    return;
}

pub struct A {
    x: i64;
}

impl TestTrait for A {
    fn name() void {
        return;
    }

    fn set(i: i64) i64 {
        self.x = i;
        return i;
    }

}

trait TestTrait {
    fn name() void;

    fn set(i: i64) i64;

}

pub fn trait_with_generic<T>(x: T) i64
where
    T: TestTrait
{
    x.name();
    return x.set(999);
}

pub fn trait_with_generic_ret<T|S>(x: T, y: S) T
where
    T: TestTrait,
    S: TestTrait
{
    x.name();
    y.name();
    return x;
}

pub fn flow() void {
    let x = (false && true_with_pnanic()) || (true || !true_with_pnanic());
    if (true || true_with_pnanic()) && (false && !true_with_pnanic() || x) {
    } else {
        panic::pl_panic();
    }
    let z = 100;
    for let i = 10; i < 15 && (i > 100 || true); i = i + 1 {
        z = z + 1;
    }
    let i = 0;
    while i > 100 || (i < 5 && i <= 6) {
        i = i + 1;
    }
    return;
}

pub fn generic_fn<A|B|C>(a: i64, x: A, y: B, z: C) i64 {
    if a == 0 {
        return 0;
    }
    if a == 1 {
        return 1;
    }
    if a == 2 {
        return 1;
    }
    return generic_fn<B|_|C>(a - 1, y, x, z) + generic_fn<C|A|_>(a - 2, z, x, y);
}

struct Point<X|Y> {
    x: X;
    y: Y;
}

impl<X1|Y1> Point<X1|Y1> {
    fn mixup<X2|Y2>(other: Point<X2|Y2>) Point<X1|Y2> {
        return Point{
            x: self.x,
            y: other.y
        };
    }

}

struct StWithTrait<T: TestTrait> {
    x: Inner<T>;
}

impl<J: TestTrait> StWithTrait<J> {
    fn call_trait() void {
        self.x.y.name();
        return;
    }

}

struct Inner<T: TestTrait> {
    y: T;
}

type AA<T> = f32 | T;
type B<T> = i32 | AA<T>;
pub fn test_union() i64 {
    let g: Option<i64> = None{};
    panic::assert(g is None);
    g = 1 as i64;
    let a: i128 = 1;
    let b: f32 = 1.;
    let c: AA<i128> = a;
    let h = c as i128?;
    let i = h as i128!;
    panic::assert(i == 1);
    let d = c;
    d = b;
    let e = a as f32;
    e = 100.1;
    let f = e as i64;
    let aa: B<i128> = d;
    let bb = aa as i32?;
    panic::assert(bb is None);
    let cc = aa as AA<i128>!;
    let dd = cc as f32!;
    panic::assert(dd == 1.);
    let j = test_ret_union() as i64!;
    panic::assert(j == 101);
    return 0;
}

fn test_ret_union() Option<i64> {
    return 101;
}

trait TA {
}

trait TB {
}

trait TC: TA+TB {
}

trait TD: TA {
}

fn test_tuple() void {
    let a: (i64, i64) = (1, 2);
    let b = (1, 2, (8, (9, 0, None{})));
    return;
}

fn fn_as_param(f: (i64, i64) => i64) (i64, i64) => i64 {
    panic::assert(f(1, 2) == 3);
    return f;
}

fn add(i: i64, j: i64) i64 {
    return i + j;
}

pub fn test_fntype() () => f {
    let f = add;
    let fc: (i64, i64) => i64 = f;
    let re = fn_as_param(fc)(2, 2);
    panic::assert(re == 4);
    let ff: () => f = test_ret_f;
    let f1 = test_ret_f().f(100, 2);
    panic::assert(f1 == 102);
    return ff;
}

fn test_ret_f() f {
    let d: (i64, i64) => i64 = add;
    return f{
        f: d
    };
}

pub struct f {
    f: (i64, i64) => i64;
}

