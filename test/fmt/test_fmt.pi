use core::panic;
const a = 100;
pub fn true_with_pnanic() bool {
    panic::pl_panic();
    return true;
}

pub struct complex_struct {
    x: i64;
    pub y: *bool;
    pub z: [base * 2];
}

/// struct coment
struct base {
}

/// fn coment
/// fn coment
fn struct_init() void {
    /// comment
    let t = complex_struct{
        x: 1,
        y: &true,
        z: [base{}, base{}]
    };
    t.z[1];
    return;
}

fn ifel() void {
    if true {
    } else {
        if true {
        }
    }
    if true {
    }
    return;
}

pub struct A {
    x: i64;
}

impl TestTrait for A {
    fn name() void {
        return;
    }

    fn set(i: i64) i64 {
        self.x = i;
        return i;
    }

}

trait TestTrait {
    fn name() void;

    fn set(i: i64) i64;

}

pub fn trait_with_generic<T>(x: T) i64
where
    T: TestTrait
{
    x.name();
    return x.set(999);
}

pub fn trait_with_generic_ret<T|S>(x: T, y: S) T
where
    T: TestTrait,
    S: TestTrait
{
    x.name();
    y.name();
    return x;
}

pub fn flow() void {
    let x = (false && true_with_pnanic()) || (true || !true_with_pnanic());
    if (true || true_with_pnanic()) && (false && !true_with_pnanic() || x) {
    } else {
        panic::pl_panic();
    }
    let z = 100;
    for let i = 10; i < 15 && (i > 100 || true); i = i + 1 {
        z = z + 1;
    }
    let i = 0;
    while i > 100 || (i < 5 && i <= 6) {
        i = i + 1;
    }
    return;
}

pub fn generic_fn<A|B|C>(a: i64, x: A, y: B, z: C) i64 {
    if a == 0 {
        return 0;
    }
    if a == 1 {
        return 1;
    }
    if a == 2 {
        return 1;
    }
    return generic_fn<B|_|C>(a - 1, y, x, z) + generic_fn<C|A|_>(a - 2, z, x, y);
}

struct Point<X|Y> {
    x: X;
    y: Y;
}

impl<X1|Y1> Point<X1|Y1> {
    fn mixup<X2|Y2>(other: Point<X2|Y2>) Point<X1|Y2> {
        return Point{
            x: self.x,
            y: other.y
        };
    }

}

