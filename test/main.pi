// use project1::test::_match;
// use project1::test::time;
// use project1::test::print;
// use project1::test::ifel;
// use project1::test::generic;
// use project1::test::st;
// use project1::test::method;
// use project1::test::global;
// use project1::test::traits;
// use project1::test::simple;
// use project1::test::flow;
// use project1::test::compiletime_reflection::test_compile_time_reflection;
// use project1::test::list;
// use project1::test::module;
// use project1::test::str;
// use project1::test::macros;
// use project1::test::union;
// use project1::test::multi_trait;
// use project1::test::tuple;
// use project1::test::fntype;
// use project1::test::closure;
// use project1::test::map;
// use project1::test::tree;
// use project1::test::fixed_point;
// use project1::test::sort_test;
// use project1::tmod2;
// // use pl_test::main;
// use project1::test::deconstruct;
// use project1::test::st::*;
// use project1::test::arr;
// use project1::test::iter;
// use project1::test::inference;
// use project1::test::rand;
// use project1::test::_hashtable;
// use project1::test::_io;
// use project1::test::future_test;
// use project1::test::std_test;
// // use std::cols::hashtable::new_hash_table;
use project1::test::std_test;


use std::libuv;
use std::thread;
use std::task::reactor;
use std::task::executor;
use std::task::delay;
use std::task::Task;
use std::task::tcp;


async fn async_1() Task<()> {
    println!("async 1");
    let _re = await delay::delay(2000 as u64);
    println!("async 1 end");

    return ();
}

pub fn main() i64 {
    std_test::test_std();
    thread::spawn(||=>{
        reactor::GLOBAL_REACTOR.start_ev_loop();
        return;
    });
    executor::GLOBAL_EXECUTOR.spawn(async_1());
    reactor::GLOBAL_REACTOR.new_tcp_listener(libuv::new_uv_tcp_t(), "0.0.0.0", 8899 as i32, async |c:* libuv::uv_tcp_t|=>{
        println!("on connect");
        let stream = tcp::new_stream_from_tcp(c);
        let buf = [u8* 10;];
        let l = await stream.read_async(buf);
        let s = gc::string_from_bytes(buf);
        println!("read len ", l, " data: ", s);
        let stat = await stream.write_async(buf);
        println!("write status ", stat);
        return ();
    });
    executor::GLOBAL_EXECUTOR.start_exec_loop();
    return 0;
}


fn async_cb(async_t:*libuv::uv_async_t) void {
    // gc::pin(async_t);
    // let p = gc::is_pinned(async_t);
    // println!("async cb ", p);
    let data = libuv::get_data_for_handle<libuv::uv_async_t|i64>(async_t);
    gc::pin(data);
    println!(*data);
    return;
}

fn idle_cb(_idle: *libuv::uv_idle_t) void {
    gc::DioGC__safepoint(asm_sp());
    return;
}
