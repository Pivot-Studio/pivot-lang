use project1::test::ifel;
use project1::test::generic;
use project1::test::st;
use project1::test::method;
use project1::test::constant;
use project1::test::traits;
use project1::test::simple;
use project1::test::flow;
use project1::test::list;
use project1::test::module;
use project1::test::string;
use project1::test::macros;
use project1::test::union;
use project1::test::multi_trait;
use project1::test::tuple;
use project1::test::fntype;
use project1::test::closure;
use project1::test::map;
use project1::test::tree;
use project1::test::fixed_point;
use project1::tmod2;
use pl_test::main;
use project1::test::compiletime_reflection::test_compile_time_reflection;
pub fn main() i64 {
    macros::test_macros();
    ifel::test_if_else();
    generic::test_generic();
    method::test_impl();
    st::test_struct();
    constant::test_const();
    traits::test_trait();
    simple::test_simple();
    flow::test_flow();
    list::test_list();
    main::simple_test();
    module::test_module();
    string::test_string();
    union::test_union();
    multi_trait::test_multi_trait();
    tuple::test_tuple();
    fntype::test_fntype()();
    closure::test_closure();
    tree::test_eva();
    map::test_map();
    fixed_point::test_fixed_point();
    // test_mod_impl1<i64>();
    // test_mod_impl1<f32>();
    generic::ret_generic1<i64>();// change this to f32
    test_compile_time_reflection();
    return 0;
}

use project1::tmod;
use project1::tmod1;
pub fn test_mod_impl1<T>() void{
    let a = 1;
    // 1.nametf();
    
    // a.nametf();
    // let n = tmod::mod_struct<i64>{};
    // tmod1::name(n);
    // n.nametf();
    return ;
}


