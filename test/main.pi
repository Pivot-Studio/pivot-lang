use std::chan::*;
use std::future::*;
use std::io;
fn new_thread(f: ||=>void) i128;
fn sleep(secs: u64) void;
pub struct SharedState {
    completed: bool;
    waker: Waker;
}

pub struct TimerFuture {
    shared_state: *SharedState;
}

impl Future<()> for TimerFuture {
    fn poll(wk: Waker) Poll<()> {
        let shared_state = self.shared_state;
        println!("polling");
        if shared_state.completed{
            return Ready<()>{v: ()};
        }else{
            shared_state.waker = wk;
            return Pending{};
        }
    }
}

pub struct TimeWaker {
    task: *Task;
}

impl Waker for TimeWaker {
    fn wake() void {
        self.task.sender.send(self.task);
        return;
    }
}
fn print_u64(u: u64) void;

pub fn new_tf(secs: u64)*TimerFuture{
    let s = secs;
    let a:Waker = TimeWaker{};
    let shared_state = &SharedState {
        completed: false,
        waker: a
    };
    // let shared_state_1 = shared_state;
    let f = ||=>void{
        gc::DioGC__enable_auto_collect();
        println!("begin sleep");
        gc::DioGC__disable_auto_collect();
        sleep(s);
        gc::DioGC__enable_auto_collect();
        println!("end sleep");
        shared_state.completed =true;
        println!("wake");
        shared_state.waker.wake();
        return;
    };
    println!("start a thread");
    gc::DioGC__disable_auto_collect();
    new_thread(f);
    let ret = TimerFuture {shared_state: shared_state};
    return &ret;
}

pub struct Task {
    time_future: *TimerFuture;
    sender: *Chan<*Task>;
}

pub struct Spawner {
    sender: *Chan<*Task>;
}

pub struct Executor {
    ready_queue: *Chan<*Task>;
}

fn new_executor_and_spawner() (Executor, Spawner) {
    let ch = &channel<*Task>(10 as u64);
    let executor = Executor{};
    executor.ready_queue = ch;
    let spawner = Spawner{};
    spawner.sender = ch;
    return (executor, spawner);
}

impl Spawner {
    fn spawn(future: *TimerFuture)void{
        let task = Task {};
        task.sender = self.sender;
        task.time_future = future;
        
        let waker = TimeWaker{};
        waker.task = &task;
        future.shared_state.waker = waker;
        // self.sender.send(&task);
        return;
    }
}

impl Executor {
    fn run()void{
        let is_pending = true;
        while is_pending {
            let t = *self.ready_queue.recv();
            let wk = t.time_future.shared_state.waker;
            let poll = t.time_future.poll(wk);
            println!("polled");
            if poll is Pending{
                continue;
            }
            println!("[run]ready");
            is_pending = false;
        }
        return;
    }
}

fn main() i64 {
    println!("new_timerfuture");
    let tf = new_tf(3 as u64);
    println!("new_executor & spawner");
    let (executor, spawner) = new_executor_and_spawner();
    println!("spawn");
    spawner.spawn(tf);
    println!("run");
    executor.run();
    println!("end");
    return 0;
}