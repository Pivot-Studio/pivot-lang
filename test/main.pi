use mod1;
use sub::mod;
use mod2;
use sub3::main;
use sub3::main::test;
use std::io;
use core::gc;
fn test_gc() void {
    let gc = gc::DioGC__new_ptr();
    io::printi64ln(gc);
    return;
}

const a = 100;
struct struct_father {
    a : i64;
    b : i64;
    c : struct_child; // 124548
}

// # 1545145211
// 1. a
// 2. b
struct struct_child {
    a : i64;
    b : [i64*1];
}


// 123

// # 123
// *hello*
// 123
// ```pivot-lang
// fn test_struct() void {
//     let s = struct_father{a:2,b:2,c:struct_child{a:2,},};
//     io::printi64ln(s.a);
//     io::printi64ln(s.a);
//     io::printi64ln(s.c.a);
//     return ;
// }
// ```
fn test_struct() void {
    let s = struct_father{a:2,b:2,c:struct_child{a:2,b:[1101,],},};
    io::printi64ln(s.a);
    io::printi64ln(s.a);
    io::printi64ln(s.c.a);
    io::printi64ln(s.c.b[0]);
    mod1::test_mod(a);
    mod2::test_mod(a);
    mod::name();
    mod1::printi64ln(1);
    main::test();
    test::test();
    return ;
}
fn test_vm() void {
    io::printi64ln(test_vm_link());//165445451
    return ;
}
fn test_if_else() void {
    test_if_only(true);
    test_if_else_ret(true);
    test_if_ret_only(true);
    test_else_ret_only(true);

    test_not_ret(true);
    return    ;
}
fn test_if_only(judge:bool) void {
    if judge {
        return ;
    }
    return;
}
fn test_if_else_ret(judge:bool) void {
    if judge {//12354121
        return ;
    } else {//123145212
        return ;
    }
}
fn test_if_ret_only(judge:bool) void {
    if judge {
        return ;
    } else {
        //156411
    }
    return ;
}
fn test_else_ret_only(judge:bool) void {
    if judge {
        ;
    } else {
        return;
    }
    return ;
}//135132123
fn test_not_ret(judge:bool) void {
    if judge {
;
    } else {

    }//156541
    return;
}
fn test_complex() void {
    let res: i64;
    res = get(get(get(get(2))));
    io::printi64ln(res);
    let b = true && !(res > 3 || res < 10);
    if b {
        io::printi64ln(res);
    }
    return;
}
fn get(x:i64) i64 {
    return ((x+1)*3 + (x/2))/5;
}
fn test_warn() void {
    return;
    let x = 1;//15154212
}
fn test_const() void {
    io::printi64ln(a);
    return;
}
fn test_mod_struct() void {
    let x = mod1::Mod1{x:2,y:mod2::Mod2{y:true,},};
    io::printi64ln(x.x);
    if x.y.y {
        io::printi64ln(x.x);
    }
    return;
}

fn test_loop() void {
    let i = 0;
    while i < 7 {
        if i == 3 {
            i = 5;
            continue;
        }
        if i==5 {
            break;
        }
        i = i + 1;
    }
    for let i = 0; i < 10; i = i + 1 {
        io::printi64ln(i);
    }
    return;
}
struct A {
    x:i64;
}
fn ret_atruct() A {
    return A{x:10000,};
}
fn ret_arr() [i64*3] {
    return [1,10000,3,];
}
fn test_ret_struct_arr() void {
    let s = ret_atruct().x;
    io::printi64ln(s);
    let a = ret_arr()[1];
    io::printi64ln(a);
    return;
}
fn main() i64 {
    let a1 = [[[1,2,],[1,2,],],];
    io::printi64ln(a1[0][0][0]);
    test_struct();
    printline();
    test_vm();
    printline();
    test_if_else();
    printline();
    test_complex();
    printline();
    test_const();
    printline();
    test_mod_struct();
    test_loop();
    test_ret_struct_arr();
    test_gc();
    let st = test_ret_struct();
    io::printi64ln(st.a);
    test_pointer();
    return 0;
}

fn test_pointer() void {
    let a = 0;
    let b = &a;
    test_modify_pointer(&b);
    io::printi64ln(*b);
    return;
}

fn test_modify_pointer(a:**i64) void {
    **a = 6;
    return;
}

fn test_vm_link() i64;
fn printline() void {
    io::printi64ln(100000000);
    return;
}

fn test_ret_struct() struct_child {
    return struct_child{a:10,};
}
