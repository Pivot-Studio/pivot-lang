use project1::mod1;
use project1::sub::mod;
use project1::mod2;
use project2::main;
use project2::main::test;
use core::panic;
use std::io;
const a = 100;
struct struct_father {
    a: i64;
    b: i64;
    c: struct_child;// 124548

}

// # 1545145211
// 1. a
// 2. b
struct struct_child {
    a: i64;
    b: [i64 * 1];
}

// 123
// # 123
// *hello*
// 123
// ```pivot-lang
// fn test_struct() void {
//     let s = struct_father{a:2,b:2,c:struct_child{a:2,},};
//     io::printi64ln(s.a);
//     io::printi64ln(s.a);
//     io::printi64ln(s.c.a);
//     return ;
// }
// ```
fn test_struct() void {
    let s = struct_father{
        a: 2,
        b: 2,
        c: struct_child{
            a: 2,
            b: [1101]
        }
    };
    io::printi64ln(s.a);
    io::printi64ln(s.a);
    io::printi64ln(s.c.a);
    io::printi64ln(s.c.b[0]);
    mod1::test_mod(a);
    mod2::test_mod(a);
    mod::name();
    mod1::printi64ln(1);
    main::test();
    test::test();
    return;
}

fn test_if_else() void {
    test_if_only(true);
    test_if_else_ret(true);
    test_if_ret_only(true);
    test_else_ret_only(true);
    test_not_ret(true);
    return;
}

fn test_if_only(judge: bool) void {
    if judge {
        return;
    }
    return;
}

fn test_if_else_ret(judge: bool) void {
    if judge {
        //12354121
        return;
    } else {
        //123145212
        return;
    }
}

fn test_if_ret_only(judge: bool) void {
    if judge {
        return;
    } else {
        //156411
    }
    return;
}

fn test_else_ret_only(judge: bool) void {
    if judge {
    } else {
        return;
    }
    return;
}

//135132123
fn test_not_ret(judge: bool) void {
    if judge {
    } else {
    }
    //156541
    return;
}

fn test_complex() void {
    let res: i64;
    res = get(get(get(get(2))));
    io::printi64ln(res);
    let b = true && !(res > 3 || res < 10);
    if b {
        io::printi64ln(res);
    }
    return;
}

fn get(x: i64) i64 {
    return ((x + 1) * 3 + (x / 2)) / 5;
}

fn test_warn() void {
    return;
    let x = 1;
    //15154212
}

fn test_const() void {
    io::printi64ln(a);
    return;
}

impl mod1::Mod1 {
    fn name() void {
        io::printi64ln(100101);
        return;
    }
}

fn test_mod_struct() void {
    let x = mod1::Mod1{x:2,y:mod2::Mod2{y:true}};
    x.name();
    io::printi64ln(x.x);
    if x.y.y {
        io::printi64ln(x.x);
    }
    return;
}

fn test_loop() void {
    let i = 0;
    while i < 7 {
        if i == 3 {
            i = 5;
            continue;
        }
        if i == 5 {
            break;
        }
        i = i + 1;
    }
    for let i = 0; i < 10; i = i + 1 {
        io::printi64ln(i);
    }
    return;
}

struct A {
    x: i64;
}

fn ret_atruct() A {
    return A{
        x: 10000
    };
}

fn ret_arr() [i64 * 3] {
    return [1, 10000, 3];
}

fn test_ret_struct_arr() void {
    let s = ret_atruct().x;
    io::printi64ln(s);
    let a = ret_arr()[1];
    io::printi64ln(a);
    return;
}

fn main() i64 {
    let a1 = [[[1, 2], [1, 2]]];
    io::printi64ln(a1[0][0][0]);
    test_struct();
    printline();
    printline();
    test_if_else();
    printline();
    test_complex();
    printline();
    test_const();
    printline();
    test_mod_struct();
    test_loop();
    test_ret_struct_arr();
    let st = test_ret_struct();
    io::printi64ln(st.a);
    test_pointer();
    return 0;
}

fn test_pointer() void {
    let a = 0;
    let b = &a;
    test_modify_pointer(&b);
    io::printi64ln(*b);
    let dang = test_dangling();
    io::printi64ln(dang.ptr.a);
    return;
}

fn test_modify_pointer(a: **i64) void {
    **a = 6;
    return;
}

struct pointer_struct {
    ptr: *struct_child;
}

fn test_dangling() *pointer_struct {
    let a = pointer_struct{
        ptr: &struct_child{
            a: 10
        }
    };
    a.name();
    return &a;
}

fn test_vm_link() i64;

fn printline() void {
    io::printi64ln(100000000);
    return;
}

fn test_ret_struct() struct_child {
    return struct_child{
        a: 10
    };
}

impl pointer_struct {
    fn name() void {
        io::printi64ln(100100);
        return;
    }
}

