use std::future::*;
fn new_thread(f: ||=>i64) void;
fn sleep(secs: i64) void;
pub struct SharedState {
    completed: bool;
    waker: Waker;
}

pub struct TimerFuture {
    shared_state: SharedState;
}

impl Future<()> for TimerFuture {
    fn poll(wk: Waker) Poll<()> {
        let shared_state = self.shared_state;
        if shared_state.completed{
            return Ready<()>{v: ()};
        }else{
            shared_state.waker = wk;
            return Pending{};
        }
    }
}

pub struct TimeWaker {
    task: *Task;
}

impl Waker for TimeWaker {
    fn wake() void {
        let task = self.task;
        task.sender = task;
        return;
    }
}


pub fn new_tf(secs: i64)*TimerFuture{
    let a:Waker = TimeWaker{};
    let shared_state = SharedState{
        completed: false,
        waker: a
    };
    let shared_state_1 = shared_state;
    new_thread(||=>i64{
        sleep(secs);
        shared_state_1.completed =true;
        shared_state_1.waker.wake();
        return 0;
    });
    let ret = TimerFuture {shared_state: shared_state};
    return &ret;
}


pub struct Task {
    time_future: *TimerFuture;
    sender: *Task;
}

pub struct Spawner {
    sender: *Task;
}

struct Executor {
    ready_queue: *Task;
}

fn new_executor_and_spawner() (Executor, Spawner) {
    let task = Task{};
    let executor = Executor{ready_queue: &task};
    let spawner = Spawner{sender: &task};
    return (executor, spawner);
}

impl Spawner {
    fn spawn(future: *TimerFuture)void{
        let task = Task {
            time_future: future,
            sender: self.sender
        };
        future.shared_state.waker = TimeWaker{task: &task};
        self.sender = &task;
        return;
    }
}

impl Executor {
    fn run()void{
        let task = *(self.ready_queue);
        while true {
            let wk = task.time_future.shared_state.waker;
            let poll = task.time_future.poll(wk);
            match_type<Ready<()>>(poll, { return; });
            match_type<Pending>(poll, {  });
        }
        return;
    }
}

fn main() i64 {
    let tf = new_tf(3);
    let (executor, spawner) = new_executor_and_spawner();
    spawner.spawn(tf);
    executor.run();
    return 0;
}
