use project1::mod1;
use project1::sub::mod;
use project1::mod2;
use project2::main;
use project2::main::test;
use core::panic;
use std::io;
use core::panic;
const a = 100;
struct struct_father {
    a: i64;
    b: i64;
    c: struct_child;// 124548

}

// # 1545145211
// 1. a
// 2. b
struct struct_child {
    a: i64;
    b: [i64 * 1];
}

/// 123
/// # 123
/// *hello*
/// 123
/// ```pivot-lang
/// fn test_struct() void {
///     let s = struct_father{a:2,b:2,c:struct_child{a:2,},};
///     io::printi64ln(s.a);
///     io::printi64ln(s.a);
///     io::printi64ln(s.c.a);
///     return ;
/// }
/// ```
fn test_struct() void {
    let s = struct_father{
        a: 2,
        b: 2,
        c: struct_child{
            a: 2,
            b: [1101]
        }
    };
    io::printi64ln(s.a);
    io::printi64ln(s.a);
    io::printi64ln(s.c.a);
    io::printi64ln(s.c.b[0]);
    mod1::test_mod(a);
    mod2::test_mod(a);
    mod::name();
    mod1::printi64ln(1);
    main::test();
    test::test();
    return;
}

fn test_if_else() void {
    test_if_only(true);
    test_if_else_ret(true);
    test_if_ret_only(true);
    test_else_ret_only(true);
    test_not_ret(true);
    return;
}

fn test_if_only(judge: bool) void {
    if judge {
        return;
    }
    return;
}

fn test_if_else_ret(judge: bool) void {
    if judge {
        //12354121
        return;
    } else {
        //123145212
        return;
    }
}

fn test_if_ret_only(judge: bool) void {
    if judge {
        return;
    } else {
        panic::pl_panic();
        //156411
    }
    return;
}

fn test_else_ret_only(judge: bool) void {
    if judge {
    } else {
        return;
    }
    return;
}

//135132123
fn test_not_ret(judge: bool) void {
    if judge {
    } else {
    }
    //156541
    return;
}

fn test_complex() void {
    let res: i64;
    res = get(get(get(get(2))));
    io::printi64ln(res);
    let b = true && !(res > 3 || res < 10);
    if b {
        io::printi64ln(res);
    }
    return;
}

fn get(x: i64) i64 {
    return ((x + 1) * 3 + (x / 2)) / 5;
}

fn test_warn() void {
    return;
    let x = 1;
    //15154212
}

////
fn test_const() void {
    io::printi64ln(a);
    return;
}

impl mod1::Mod1 {
    //
    /// ### xxx
    //
    /// *0123*
    fn name() void {
        self.x = 114514;
        io::printi64ln(100101);
        return;
    }

}

/// ANCHOR_END: extern_impl
fn test_mod_struct() void {
    let x = mod1::Mod1{
        x: 2,
        y: mod2::Mod2{
            y: true
        }
    };
    x.name();
    io::printi64ln(x.x);
    if x.y.y {
        io::printi64ln(x.x);
    }
    return;
}

fn test_loop() void {
    //12255
    let i = 0;
    while i < 7 {
        if i == 3 {
            i = 5;
            continue;
        }
        if i == 5 {
            break;
        }
        i = i + 1;
    }
    for let i = 0; i < 10; i = i + 1 {
        io::printi64ln(i);
    }
    return;
}

struct A {
    x: i64;
}

fn ret_atruct() A {
    return A{
        x: 10000
    };
}

fn ret_arr() [i64 * 3] {
    return [1, 10000, 3];
}

//12321
///# 123
/// ~123~
fn test_ret_struct_arr() void {
    let s = ret_atruct().x;
    io::printi64ln(s);
    let a = ret_arr()[1];
    io::printi64ln(a);
    return;
}

fn test_generic() void {
    let x = generic(114514);
    let y = generic(true);
    if y {
        io::printi64ln(x);
    }
    let t = true;
    let a = GenericType{
        x: 999,
        y: &t
    };
    let b = GenericType{
        x: 888,
        y: &a
    };
    if *b.y.y {
        io::printi64ln(b.y.x);
    }
    let g = GenericOutter{
        x: GenericInner{
            x: 998
        }
    };
    io::printi64ln(g.x.x);
    return;
}

struct GenericType<S|T> {
    x: S;
    y: *T;
}

struct GenericOutter<S> {
    x: GenericInner<S>;
}

struct GenericInner<T> {
    x: T;
}

fn generic<T>(x: T) T {
    let y = x;
    return y;
}

fn test_generic_same_name() void {
    let t = Three{
        c: Two{
            b: One{
                a: 9999
            }
        }
    };
    let b = Three<bool>{};
    b.c.b.a = true;
    if b.c.b.a {
        io::printi64ln(t.c.b.a);
    }
    return;
}

fn test_ret_generic() void {
    let x = ret_generic1<i64>();
    let y = ret_generic2(true);
    let z = ret_generic2([1, 2, 3]);
    let i = ret_generic2(&z);
    if y.c.b.a {
        io::printi64ln(x.c.b.a);
    }
    return;
}

fn ret_generic1<T>() Three<T> {
    return Three<T>{};
}

fn ret_generic2<T>(x: T) Three<T> {
    let two = Two{
        b: One{
            a: x
        }
    };
    return Three{
        c: two
    };
}

fn test_self_ref_generic() void {
    let x = GenericSelfRef<i64|bool>{};
    return;
}

struct GenericSelfRef<T|S> {
    x: *GenericSelfRef<T|S>;
}

struct One<T> {
    a: T;
}

struct Two<T> {
    b: One<T>;
}

struct Three<T> {
    c: Two<T>;
}

fn test_generic_fn_simple<T>(x: i64) void {
    if x > 5 {
        return;
    }
    io::printi64ln(x);
    test_generic_fn_simple<T>(x + 1);
    return;
}

fn test_generic_fn_complex<A|B|C>(a: i64, x: A, y: B, z: C) void {
    if a > 5 {
        return;
    }
    io::printi64ln(a);
    test_generic_fn_complex<B|A|C>(a + 1, y, x, z);
    test_generic_fn_complex<C|A|_>(a + 1, z, x, y);
    return;
}

fn main() i64 {
    let a1 = [[[1, 2], [1, 2]]];
    io::printi64ln(a1[0][0][0]);
    test_struct();
    test_if_else();
    test_complex();
    test_const();
    test_mod_struct();
    test_loop();
    test_ret_struct_arr();
    test_ret_struct().a;
    /// 123
    let st = test_ret_struct();
    io::printi64ln(st.a);
    test_pointer();
    test_primitives();
    test_self_ref();
    test_many_params(1, 1, 3, 4);
    test_generic();
    test_generic_same_name();
    test_ret_generic();
    test_self_ref_generic();
    test_generic_fn_simple<bool>(1);
    test_generic_fn_complex(1, true, [12, 3], 2);
    let dd:TestTrait;
    return 0;
}
trait TestTrait {
    fn name() void;
}

fn test_many_params(a: i64, b: i64, c: i64, d: i64) void {
    return;
}

fn test_pointer() void {
    let a = 0;
    let b = &a;
    test_modify_pointer(&b);
    io::printi64ln(*b);
    let dang = test_dangling();
    io::printi64ln(dang.ptr.a);
    return;
}

fn test_modify_pointer(a: **i64) void {
    **a = 6;
    return;
}

struct pointer_struct {
    ptr2: **pointer_struct;
    ptr: *struct_child;
}

fn test_self_ref() void {
    let a = pointer_struct{
        ptr2: &&pointer_struct{
            ptr2: &&pointer_struct{
                ptr: &struct_child{
                    a: 100
                }
            }
        }
    };
    io::printi64ln(a.ptr2.ptr2.ptr.a);
    return;
}

fn test_dangling() *pointer_struct {
    let a = pointer_struct{
        ptr: &struct_child{
            a: 10
        }
    };
    a.name();
    a.name_params(1);
    return &a;
}

fn test_vm_link() i64;

fn test_ret_struct() struct_child {
    return struct_child{
        a: 10
    };
}

/// ANCHOR: impl
impl pointer_struct {
    fn name() void {
        io::printi64ln(100100);
        return;
    }

    fn name_params(x: i64) void {
        return;
    }

}

/// ANCHOR_END: impl
fn test_primitives() void {
    let test: i8 = 1;
    test = -test;
    let test2: i8 = test + 1;
    let testf32: f32 = 1.1;
    testf32 = -testf32;
    testf32 = testf32 + 1.2;
    let utest: u8 = 1;
    utest = utest + 2;
    return;
}

//123
//
