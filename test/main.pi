use project1::mod1;
use project1::sub::mod;
use project1::mod2;
use project2::main;
use project2::main::test;
use core::panic;
use std::io;
use core::panic;
const a = 100;
struct struct_father {
    a: i64;
    b: i64;
    c: struct_child;// 124548

}

// # 1545145211
// 1. a
// 2. b
struct struct_child {
    a: i64;
    b: [i64 * 1];
}

// 123
// # 123
// *hello*
// 123
// ```pivot-lang
// fn test_struct() void {
//     let s = struct_father{a:2,b:2,c:struct_child{a:2,},};
//     io::printi64ln(s.a);
//     io::printi64ln(s.a);
//     io::printi64ln(s.c.a);
//     return ;
// }
// ```
fn test_struct() void {
    let s = struct_father{
        a: 2,
        b: 2,
        c: struct_child{
            a: 2,
            b: [1101]
        }
    };
    io::printi64ln(s.a);
    io::printi64ln(s.a);
    io::printi64ln(s.c.a);
    io::printi64ln(s.c.b[0]);
    mod1::test_mod(a);
    mod2::test_mod(a);
    mod::name();
    mod1::printi64ln(1);
    main::test();
    test::test();
    return;
}

fn test_if_else() void {
    test_if_only(true);
    test_if_else_ret(true);
    test_if_ret_only(true);
    test_else_ret_only(true);
    test_not_ret(true);
    return;
}

fn test_if_only(judge: bool) void {
    if judge {
        return;
    }
    return;
}

fn test_if_else_ret(judge: bool) void {
    if judge {
        //12354121
        return;
    } else {
        //123145212
        return;
    }
}

fn test_if_ret_only(judge: bool) void {
    if judge {
        return;
    } else {
        panic::pl_panic();
        //156411
    }
    return;
}

fn test_else_ret_only(judge: bool) void {
    if judge {
    } else {
        return;
    }
    return;
}

//135132123
fn test_not_ret(judge: bool) void {
    if judge {
    } else {
    }
    //156541
    return;
}

fn test_complex() void {
    let res: i64;
    res = get(get(get(get(2))));
    io::printi64ln(res);
    let b = true && !(res > 3 || res < 10);
    if b {
        io::printi64ln(res);
    }
    return;
}

fn get(x: i64) i64 {
    return ((x + 1) * 3 + (x / 2)) / 5;
}

fn test_warn() void {
    return;
    let x = 1;
    //15154212
}

fn test_const() void {
    io::printi64ln(a);
    return;
}
/// ANCHOR: extern_impl

impl mod1::Mod1 {
    // xxx
    fn name() void {
        self.x = 114514;
        io::printi64ln(100101);
        return;
    }
}

/// ANCHOR_END: extern_impl
fn test_mod_struct() void {
    let x = mod1::Mod1{
        x: 2,
        y: mod2::Mod2{
            y: true
        }
    };
    x.name();
    io::printi64ln(x.x);
    if x.y.y {
        io::printi64ln(x.x);
    }
    return;
}

fn test_loop() void {
    let i = 0;
    while i < 7 {
        if i == 3 {
            i = 5;
            continue;
        }
        if i == 5 {
            break;
        }
        i = i + 1;
    }
    for let i = 0; i < 10; i = i + 1 {
        io::printi64ln(i);
    }
    return;
}

struct A {
    x: i64;
}

fn ret_atruct() A {
    return A{
        x: 10000
    };
}

fn ret_arr() [i64 * 3] {
    return [1, 10000, 3];
}

fn test_ret_struct_arr() void {
    let s = ret_atruct().x;
    io::printi64ln(s);
    let a = ret_arr()[1];
    io::printi64ln(a);
    return;
}

fn test_generic() void {
    let x = generic(114514);
    let y = generic(true);
    if y {
        io::printi64ln(x);
    }
    let t = true;
    let a = GenericType{
        x: 999,
        y: &t
    };
    let b = GenericType{
        x: 888,
        y: &a
    };
    if *b.y.y {
        io::printi64ln(b.y.x);
    }
    let g = GenericOutter{
        x: GenericInner{
            x: 998
        }
    };
    io::printi64ln(g.x.x);
    return;
}

struct GenericType<S|T> {
    x: S;
    y: *T;
}

struct GenericOutter<S> {
    x: GenericInner<S>;
}

struct GenericInner<T> {
    x: T;
}

fn generic<T>(x: T) T {
    let y = x;
    return y;
}

fn main() i64 {
    let a1 = [[[1, 2], [1, 2]]];
    io::printi64ln(a1[0][0][0]);
    test_struct();
    test_if_else();
    test_complex();
    test_const();
    test_mod_struct();
    test_loop();
    test_ret_struct_arr();
    let st = test_ret_struct();
    io::printi64ln(st.a);
    test_pointer();
    test_primitives();
    test_self_ref();
    test_many_params(1, 1, 3, 4);
    test_generic();
    return 0;
}

fn test_many_params(a: i64, b: i64, c: i64, d: i64) void {
    return;
}

fn test_pointer() void {
    let a = 0;
    let b = &a;
    test_modify_pointer(&b);
    io::printi64ln(*b);
    let dang = test_dangling();
    io::printi64ln(dang.ptr.a);
    return;
}

fn test_modify_pointer(a: **i64) void {
    **a = 6;
    return;
}

struct pointer_struct {
    ptr2: **pointer_struct;
    ptr: *struct_child;
}

fn test_self_ref() void {
    let a = pointer_struct{
        ptr2: &&pointer_struct{
            ptr2: &&pointer_struct{
                ptr: &struct_child{
                    a: 100
                }
            }
        }
    };
    io::printi64ln(a.ptr2.ptr2.ptr.a);
    return;
}

fn test_dangling() *pointer_struct {
    let a = pointer_struct{
        ptr: &struct_child{
            a: 10
        }
    };
    a.name();
    a.name_params(1);
    return &a;
}

fn test_vm_link() i64;

fn test_ret_struct() struct_child {
    return struct_child{
        a: 10
    };
}
/// ANCHOR: impl

impl pointer_struct {
    fn name() void {
        io::printi64ln(100100);
        return;
    }

    fn name_params(x: i64) void {
        return;
    }
}

/// ANCHOR_END: impl
fn test_primitives() void {
    let test: i8 = 1;
    test = -test;
    let test2: i8 = test + 1;
    let testf32: f32 = 1.1;
    testf32 = -testf32;
    testf32 = testf32 + 1.2;
    let utest: u8 = 1;
    utest = utest + 2;
    return;
}
