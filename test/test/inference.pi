pub fn test_inference() void {
    let x;
    x = 100;
    let y;
    y = x;

    let z;
    test_f_infer(z);
    let d;
    d = test_f_infer(z);
    let a = t{};
    let l;
    l = a.a;
    let h = |a| =>{
        return a==a;
    };
    h(100);
    let hh = |a,b,c| =>{
        return b;
    }(1,1.2,t{});
    let yy;
    yy = ~y;
    let xx ;
    xx = &(~y);
    test_deconstruct_inference();
    test_generic_inference();
    return;
}

fn test_generic_inference() void {
    let ad ;
    ad = st {};
    ad.a = 100;

    let ad2;
    ad2 = st2 {};
    ad2.taaa.a = 1;
    ad2.b = 2.0;
    let ad3;
    ad3 = st3 {};
    let b;
    ad3.a = &b;
    b = 1;
    
    let f ;
    f = |a| => {
        return;
    };
    let ad4 = st3{};
    ad4.d = f;
    f(1);

    let c  ;
    let ad5 = st3{};
    c = [&b];
    ad5.c = c;



    let d;
    let ad6 = st3{};
    ad6.e = d;
    d = (1,2);
    

    return;
}


fn test_inference_no_run() void {
    let e;
    let ad7 = st3{};
    ad7.c[0] = &e ;
    e = 10;
    return;
}


struct st3<TB> {
    a:*TB;
    d:|TB|=>void;
    c:[*TB];
    e:(TB, TB);
}

fn test_deconstruct_inference() void {
    let a;
    let b;
    let c;
    let d;
    let e;
    let f;
    (a,(b,c)) = (d,(e,f));
    let func = |a,b|=> {
        let c = a + b + 1;
        return c;
    };
    f = func(d,e);
    let g;
    g = generic_f(1);
    let dddd;

    let eeee ;
    dddd = st{};
    eeee = dddd.test(eeee);
    eeee = 1;
    return;
}

fn test_f_infer(x:i32) i128 {
    
    return x as i128;
}


fn generic_f<T>(a:T) T {
    
    return a;
}

struct t {
    a:i16;
}

struct st<T> {
    a:T;
}

struct st2<T|TT> {
    taaa:st<T>;
    b:TT;
}


impl <T> st<T> {
    fn test(t:T) T {
        
        return self.a;
    }
}

