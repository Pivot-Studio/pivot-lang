use core::panic;

struct Double {
    d: u64;
}

// impl ToString for Double {
//     fn to_string() gc::string {
//         return self.d.to_string();
//     }
// }

fn newDouble(d: f64) Double {
    return Double{
        d: *unsafe_cast<u64>(&d)
    };
}

impl Double {
    fn value() f64 {
        return *unsafe_cast<f64>(&self.d);
    }

    /// 非规格化数
    fn is_denormal() bool {
        return (self.d & 0x7ff0_0000_0000_0000) == 0;
    }

    /// 尾数 
    fn significand() u64 {
        let d = self.d & 0x000f_ffff_ffff_ffff;
        if self.is_denormal() {
            // 非规格化数，尾数 [0, 1]，指数 000(-1022)
            return d;
        }
        // 规格化数，尾数 [1, 2)，指数 [001(-1022), 7fe(1023)]
        return d + 0x0010_0000_0000_0000;
    }

    /// 指数
    fn exponent() i64 {
        if self.is_denormal() {
            return -1074;
        }
        let biased_e =((self.d & 0x7ff0_0000_0000_0000) >> 52) as i64;
        return biased_e - 1075;
    }

    fn as_F64() F64 {
        return F64{
            f: self.significand(),
            e: self.exponent()
        };
    }

    fn as_normal_F64() F64 {
        panic::assert(self.value() > 0.0);
        let f = self.significand();
        let e = self.exponent();
        while (f & 0x0010_0000_0000_0000) == 0 {
            f = f << 1;
            e = e - 1;
        }
        f = f << 11;
        e = e - 11;
        return F64{f: f, e: e};
    }

    fn lower_boundary_is_closer() bool {
        let siz = (self.d & 0x000f_ffff_ffff_ffff) == 0;
        return siz && (self.exponent() != -1074); // +Inf or -Inf
    }

    fn normalize_boundaries() (F64, F64) {
        panic::assert(self.value()>0.0);
        let v = self.as_F64();
        let m_plus = F64{f: (v.f << 1) + 1, e: v.e - 1};
        m_plus.normalize();
        let m_minus: F64;
        if self.lower_boundary_is_closer() {
            m_minus = F64{f: (v.f << 2) - 1, e: v.e - 2};
        } else {
            m_minus = F64{f: (v.f << 1) - 1, e: v.e - 1};
        }
        m_minus.f = m_minus.f << (m_minus.e - m_plus.e) as u64;
        m_minus.e = m_plus.e;
        return (m_minus, m_plus);
    }
}

struct F64 {
    f: u64;
    e: i64;
}

// impl ToString for F64 {
//     fn to_string() gc::string {
//         let ret = "{ f: ";
//         ret.append(self.f.to_string());
//         ret.append(", e: ");
//         ret.append(self.e.to_string());
//         ret.append(" }");
//         return ret;
//     }
// }

fn minF64(a: F64, b: F64) F64 {
    if a.cmp(b) < 0 {
        return a;
    }
    return b;
}

impl F64 {
    fn is_denormal() bool {
        let nf = *self;
        nf.normalize();
        if nf.e < -1074-12 {
            return true;
        }
        return false;
    }

    fn value() f64 {
        let v = *self;
        v.normalize();
        let f = v.f;
        let e = v.e;
        if v.is_denormal() {
            f = f >> (-1074-12-e) as u64;
            f = f & 0x000f_ffff_ffff_ffff;
            return *unsafe_cast<f64>(&f);
        }
        f = (f >> 11) & 0x000f_ffff_ffff_ffff | ((e + 1075 + 11) as u64 << 52);
        return *unsafe_cast<f64>(&f);
    }

    fn normalize() void {
        let f = self.f;
        let e = self.e;
        while (f & 0xffc0_0000_0000_0000) == 0 {
            f = f<<10;
            e = e-10;
        }
        while (f & 0x8000_0000_0000_0000) == 0 {
            f = f<<1;
            e = e-1;
        }
        self.f = f;
        self.e = e;
        return;
    }

    fn times(f: F64) F64 {
        let a = (self.f >> 32) & 0xffff_ffff;
        let b = self.f & 0xffff_ffff;
        let c = (f.f >> 32) & 0xffff_ffff;
        let d = f.f & 0xffff_ffff;
        let ac = a * c;
        let bc = b * c;
        let ad = a * d;
        let bd = b * d;
        let tmp = (bd >> 32) + (ad & 0xffff_ffff) + (bc & 0xfff_fffff);
        tmp = tmp + (1 as u64 << 31);
        let rf = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
        let re = self.e + f.e + 64;
        return F64{f: rf, e: re};
    }

    fn sub(f: F64) F64 {
        panic::assert(self.e == f.e);
        panic::assert(self.f >= f.f);
        let nf = self.f - f.f;
        return F64{f:nf, e:f.e};
    }

    fn cmp(f: F64) i64 {
        panic::assert(self.e == f.e);
        if self.f < f.f {
            return -1;
        } else if self.f == f.f {
            return 0;
        } else {
            return 1;
        }
    }
}

/// convert f64 to string use grisu2 algorithm
pub fn grisu3(v: f64, _mode: i64, buf: [u8], len: *i64, de: *i64) bool {
    let w = newDouble(v).as_normal_F64();
    let (boundary_minus, boundary_plus) = newDouble(v).normalize_boundaries();
    panic::assert(boundary_plus.e == w.e);
    let ten_mk_minimal_binary_exponent = -60 - (w.e + 64);
    let ten_mk_maximal_binary_exponent = -32 - (w.e + 64);
    let mk: i64;
    let ten_mk: F64;
    GetCachedPowerForBinaryExponentRange(ten_mk_minimal_binary_exponent,ten_mk_maximal_binary_exponent, &ten_mk, &mk);
    panic::assert((w.e+ten_mk.e+64>=-60)&&(w.e+ten_mk.e+64<=-32));
    let scaled_w = w.times(ten_mk);
    panic::assert(scaled_w.e == boundary_plus.e + ten_mk.e + 64);

    let scaled_boundary_minus = boundary_minus.times(ten_mk);
    let scaled_boundary_plus = boundary_plus.times(ten_mk);
    let kappa: i64;
    let success = digit_gen(scaled_boundary_minus, scaled_w, scaled_boundary_plus, buf, len, &kappa);
    *de = - mk + kappa;
    return success;
}

fn digit_gen(low: F64, w: F64, high: F64, buf: [u8], len: *i64, kappa: *i64) bool {
    panic::assert(low.e==w.e&&w.e==high.e);
    panic::assert(low.f+1<=high.f-1);
    panic::assert(w.e>=-60&&w.e<=-32);
    let too_low = F64{f:low.f-1, e:low.e};
    let too_high = F64{f:high.f+1, e:high.e};
    let unsafe_interval = too_high.sub(too_low);
    let one = F64{f: (1 << (-w.e)) as u64, e: w.e};
    let integrals = (too_high.f >> (-one.e) as u64);
    let fractionals = too_high.f & (one.f - 1);
    let divisor_exponent_plus_one: i64;
    let divisor: u64;
    biggest_power_10(integrals, 64-(-one.e), &divisor, &divisor_exponent_plus_one);
    *kappa = divisor_exponent_plus_one;
    *len = 0;
    while *kappa > 0 {
        let digit = integrals / divisor;
        panic::assert(digit <= 9);
        buf[*len] = digit as u8 + 0x30 as u8;
        *len = *len + 1;
        integrals = integrals % divisor;
        *kappa = *kappa - 1;
        let rest = (integrals as u64 << (-one.e) as u64) + fractionals;
        if rest < unsafe_interval.f {
            let ret = round_weed(buf, *len, minF64(too_high, w).f, unsafe_interval.f, rest, divisor << (-one.e) as u64, 1 as u64);
            return ret;
        }
        divisor = divisor / 10;
    }
    panic::assert(one.e >= -60);
    panic::assert(fractionals < one.f);
    panic::assert(0xffff_ffff_ffff_ffff as u64 / 10 >= one.f);
    let unit = 1 as u64;
    while true {
        fractionals = fractionals * 10;
        unit = unit * 10;
        unsafe_interval.f = unsafe_interval.f * 10;
        let digit = (fractionals >> (-one.e) as u64);
        panic::assert(digit <= 9);
        buf[*len] = digit as u8 + 0x30 as u8;
        *len = *len + 1;
        fractionals = fractionals & (one.f - 1);
        *kappa = *kappa - 1;
        if fractionals < unsafe_interval.f {
            let ret = round_weed(buf, *len, minF64(too_high, w).f * unit, unsafe_interval.f, fractionals, one.f, unit);
            return ret;
        }
    }
    return false;
}

var kSmallPowersOfTen = &[
    0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
];

fn biggest_power_10(n: u64, nbs: i64, power: *u64, exponent_plus_one: *i64) void {
    panic::assert(n < (1<<(nbs+1)) as u64);
    let exponent_plus_one_guess = (nbs+1)*1233 >> 12;
    exponent_plus_one_guess = exponent_plus_one_guess + 1;
    if n < (*kSmallPowersOfTen)[exponent_plus_one_guess] as u64 {
        exponent_plus_one_guess = exponent_plus_one_guess - 1;
    }
    *power = (*kSmallPowersOfTen)[exponent_plus_one_guess] as u64;
    *exponent_plus_one = exponent_plus_one_guess;
    return;
}

fn round_weed(buf: [u8], len: i64, distance_too_high_w: u64, unsafe_interval: u64, rest: u64, ten_kappa: u64, unit: u64) bool {
    // print!(buf);
    let small_distance = distance_too_high_w - unit;
    let big_distance = distance_too_high_w + unit;
    panic::assert(rest <= unsafe_interval);
    while rest < small_distance && unsafe_interval - rest >= ten_kappa && (rest + ten_kappa < small_distance || small_distance - rest >= rest + ten_kappa - small_distance) {
        buf[len-1] = buf[len-1] - 1;
        rest = rest + ten_kappa;
    }
    if rest < big_distance && unsafe_interval - rest >= ten_kappa && (rest + ten_kappa < big_distance || big_distance - rest > rest + ten_kappa - big_distance) {
        return false;
    }
    return (unit * 2 <= rest) && (rest <= unsafe_interval - unit * 4);
}

struct CachedPower {
    significand: u64;
    binary_exponent: i64;
    decimal_exponent: i64;
}

fn cached_power(s: i64, be: i64, de: i64) CachedPower {
    return CachedPower{significand: s as u64, binary_exponent: be, decimal_exponent: de};
}

fn GetCachedPowerForBinaryExponentRange(mine: i64, maxe: i64, ten_mk: *F64, de: *i64) void {
    let k = ((mine + 63) as f64 * 0.30102999566398114) as i64;
    let index = (348 + k -1) / 8 + 1;
    panic::assert(index >= 0 && index <= 87);
    let cp = (*CachedPowers)[index];
    panic::assert(cp.binary_exponent >= mine);
    panic::assert(cp.binary_exponent <= maxe);
    *ten_mk = F64 {
        f: cp.significand,
        e: cp.binary_exponent
    };
    *de = cp.decimal_exponent;
    return;
}

var CachedPowers = &[
    cached_power(0xfa8fd5a0_081c0288, -1220, -348),
    cached_power(0xbaaee17f_a23ebf76, -1193, -340),
    cached_power(0x8b16fb20_3055ac76, -1166, -332),
    cached_power(0xcf42894a_5dce35ea, -1140, -324),
    cached_power(0x9a6bb0aa_55653b2d, -1113, -316),
    cached_power(0xe61acf03_3d1a45df, -1087, -308),
    cached_power(0xab70fe17_c79ac6ca, -1060, -300),
    cached_power(0xff77b1fc_bebcdc4f, -1034, -292),
    cached_power(0xbe5691ef_416bd60c, -1007, -284),
    cached_power(0x8dd01fad_907ffc3c, -980, -276),
    cached_power(0xd3515c28_31559a83, -954, -268),
    cached_power(0x9d71ac8f_ada6c9b5, -927, -260),
    cached_power(0xea9c2277_23ee8bcb, -901, -252),
    cached_power(0xaecc4991_4078536d, -874, -244),
    cached_power(0x823c1279_5db6ce57, -847, -236),
    cached_power(0xc2109436_4dfb5637, -821, -228),
    cached_power(0x9096ea6f_3848984f, -794, -220),
    cached_power(0xd77485cb_25823ac7, -768, -212),
    cached_power(0xa086cfcd_97bf97f4, -741, -204),
    cached_power(0xef340a98_172aace5, -715, -196),
    cached_power(0xb23867fb_2a35b28e, -688, -188),
    cached_power(0x84c8d4df_d2c63f3b, -661, -180),
    cached_power(0xc5dd4427_1ad3cdba, -635, -172),
    cached_power(0x936b9fce_bb25c996, -608, -164),
    cached_power(0xdbac6c24_7d62a584, -582, -156),
    cached_power(0xa3ab6658_0d5fdaf6, -555, -148),
    cached_power(0xf3e2f893_dec3f126, -529, -140),
    cached_power(0xb5b5ada8_aaff80b8, -502, -132),
    cached_power(0x87625f05_6c7c4a8b, -475, -124),
    cached_power(0xc9bcff60_34c13053, -449, -116),
    cached_power(0x964e858c_91ba2655, -422, -108),
    cached_power(0xdff97724_70297ebd, -396, -100),
    cached_power(0xa6dfbd9f_b8e5b88f, -369, -92),
    cached_power(0xf8a95fcf_88747d94, -343, -84),
    cached_power(0xb9447093_8fa89bcf, -316, -76),
    cached_power(0x8a08f0f8_bf0f156b, -289, -68),
    cached_power(0xcdb02555_653131b6, -263, -60),
    cached_power(0x993fe2c6_d07b7fac, -236, -52),
    cached_power(0xe45c10c4_2a2b3b06, -210, -44),
    cached_power(0xaa242499_697392d3, -183, -36),
    cached_power(0xfd87b5f2_8300ca0e, -157, -28),
    cached_power(0xbce50864_92111aeb, -130, -20),
    cached_power(0x8cbccc09_6f5088cc, -103, -12),
    cached_power(0xd1b71758_e219652c, -77, -4),
    cached_power(0x9c400000_00000000, -50, 4),
    cached_power(0xe8d4a510_00000000, -24, 12),
    cached_power(0xad78ebc5_ac620000, 3, 20),
    cached_power(0x813f3978_f8940984, 30, 28),
    cached_power(0xc097ce7b_c90715b3, 56, 36),
    cached_power(0x8f7e32ce_7bea5c70, 83, 44),
    cached_power(0xd5d238a4_abe98068, 109, 52),
    cached_power(0x9f4f2726_179a2245, 136, 60),
    cached_power(0xed63a231_d4c4fb27, 162, 68),
    cached_power(0xb0de6538_8cc8ada8, 189, 76),
    cached_power(0x83c7088e_1aab65db, 216, 84),
    cached_power(0xc45d1df9_42711d9a, 242, 92),
    cached_power(0x924d692c_a61be758, 269, 100),
    cached_power(0xda01ee64_1a708dea, 295, 108),
    cached_power(0xa26da399_9aef774a, 322, 116),
    cached_power(0xf209787b_b47d6b85, 348, 124),
    cached_power(0xb454e4a1_79dd1877, 375, 132),
    cached_power(0x865b8692_5b9bc5c2, 402, 140),
    cached_power(0xc83553c5_c8965d3d, 428, 148),
    cached_power(0x952ab45c_fa97a0b3, 455, 156),
    cached_power(0xde469fbd_99a05fe3, 481, 164),
    cached_power(0xa59bc234_db398c25, 508, 172),
    cached_power(0xf6c69a72_a3989f5c, 534, 180),
    cached_power(0xb7dcbf53_54e9bece, 561, 188),
    cached_power(0x88fcf317_f22241e2, 588, 196),
    cached_power(0xcc20ce9b_d35c78a5, 614, 204),
    cached_power(0x98165af3_7b2153df, 641, 212),
    cached_power(0xe2a0b5dc_971f303a, 667, 220),
    cached_power(0xa8d9d153_5ce3b396, 694, 228),
    cached_power(0xfb9b7cd9_a4a7443c, 720, 236),
    cached_power(0xbb764c4c_a7a44410, 747, 244),
    cached_power(0x8bab8eef_b6409c1a, 774, 252),
    cached_power(0xd01fef10_a657842c, 800, 260),
    cached_power(0x9b10a4e5_e9913129, 827, 268),
    cached_power(0xe7109bfb_a19c0c9d, 853, 276),
    cached_power(0xac2820d9_623bf429, 880, 284),
    cached_power(0x80444b5e_7aa7cf85, 907, 292),
    cached_power(0xbf21e440_03acdd2d, 933, 300),
    cached_power(0x8e679c2f_5e44ff8f, 960, 308),
    cached_power(0xd433179d_9c8cb841, 986, 316),
    cached_power(0x9e19db92_b4e31ba9, 1013, 324),
    cached_power(0xeb96bf6e_badf77d9, 1039, 332),
    cached_power(0xaf87023b_9bf0ee6b, 1066, 340)
];