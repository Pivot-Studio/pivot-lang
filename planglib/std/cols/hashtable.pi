use core::hash::*;
use core::hash::hasher::*;
use core::hash::pl_hash::*;
use core::eq::*;




pub struct HashTable<G:Hash+Eq<G>|V> {
    total_buckets:u64;
    buckets:[Option<TableNode<G|V>>];
    salt:u64;
}



struct TableNode<Y:Hash+Eq<Y>|V> {
    key:Y;
    value:V;
    hash:u64;
    next:Option<TableNode<Y|V>>;
}



impl <K:Hash+Eq<K>|V> HashTable<K|V>  {
    pub fn insert(k:K,v:V) void {
        let hasher = new_paul_larson_hasher(self.salt);
        k.hash(&hasher);
        let hash = hasher.finish();
        let bucket = hash % self.total_buckets;
        let next:Option<TableNode<K|V>> = None{};
        let node = TableNode<K|V> {
            key:k,
            value:v,
            next:next,
            hash:hash,
        };
        let current = self.buckets[bucket as i64];
        if current is None {
            self.buckets[bucket as i64] = node;
        } else {
            // check if there's same key
            let head = current as TableNode<K|V>!;
            while !head.next is None {
                if head.key.eq(&k) {
                    head.value = v;
                    return;
                }
                head = head.next as TableNode<K|V>!;
            }
            // if the key doesn't exist, insert it to the head
            // as the head is the most recently used
            let new_head = node;
            new_head.next = head;
            self.buckets[bucket as i64] = new_head;
        }
        
        return;
    }

    pub fn get(k:K) Option<V> {
        let hasher = new_paul_larson_hasher(self.salt);
        k.hash(&hasher);
        let hash = hasher.finish();
        let bucket = hash % self.total_buckets;
        let current = self.buckets[bucket as i64];
        if current is None {
            return None{};
        } else {
            // current = self.buckets[bucket as i64];
            let head = current as TableNode<K|V>!;
            while !head.next is None {
                if head.hash == hash {
                    return head.value;
                }
                head = head.next as TableNode<K|V>!;
            }
            if head.key.eq(&k) {
                return head.value;
            }

            return None{};
        }
    }
    
}





pub fn new_hash_table<K:Hash+Eq<K>|V>(bucket_size:u64,salt:u64) HashTable<K|V> {
    let  total_buckets = bucket_size;
    let  table = HashTable<K|V> {
        total_buckets:total_buckets,
        buckets:[Option<TableNode<K|V>>*bucket_size as i64;],
        salt:salt,
    };
    // init to None
    for let i = 0; i < arr_len( table.buckets); i = i + 1 {
        table.buckets[i] = None{};
    }
    return table;
}




