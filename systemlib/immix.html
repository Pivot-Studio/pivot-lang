<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Immix Gc - Pivot Lang</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../About.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="../tutorial/index.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../tutorial/basicproject.html"><strong aria-hidden="true">2.2.</strong> Basic Project</a></li><li class="chapter-item expanded "><a href="../tutorial/vscsupport.html"><strong aria-hidden="true">2.3.</strong> VSC Support</a></li></ol></li><li class="chapter-item expanded "><a href="../references/index.html"><strong aria-hidden="true">3.</strong> References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../references/module.html"><strong aria-hidden="true">3.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="../references/method.html"><strong aria-hidden="true">3.2.</strong> Method</a></li><li class="chapter-item expanded "><a href="../references/interface.html"><strong aria-hidden="true">3.3.</strong> Trait</a></li><li class="chapter-item expanded "><a href="../references/deconstruct.html"><strong aria-hidden="true">3.4.</strong> Deconstruct</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">How the project works internally</li><li class="chapter-item expanded "><a href="../dev-prepare.html"><strong aria-hidden="true">4.</strong> Dev Prepare</a></li><li class="chapter-item expanded "><a href="../compiler/index.html"><strong aria-hidden="true">5.</strong> Compiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../compiler/parser.html"><strong aria-hidden="true">5.1.</strong> Parser</a></li><li class="chapter-item expanded "><a href="../compiler/ast.html"><strong aria-hidden="true">5.2.</strong> AST</a></li><li class="chapter-item expanded "><a href="../compiler/flow.html"><strong aria-hidden="true">5.3.</strong> Flow Chart</a></li></ol></li><li class="chapter-item expanded "><a href="../lsp/index.html"><strong aria-hidden="true">6.</strong> Language Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lsp/design.html"><strong aria-hidden="true">6.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="../lsp/diagnostic.html"><strong aria-hidden="true">6.2.</strong> Diagnostic</a></li></ol></li><li class="chapter-item expanded "><a href="../systemlib/index.html"><strong aria-hidden="true">7.</strong> System library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../systemlib/vm.html"><strong aria-hidden="true">7.1.</strong> vm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../systemlib/gc.html"><strong aria-hidden="true">7.1.1.</strong> gc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../systemlib/immix.html" class="active"><strong aria-hidden="true">7.1.1.1.</strong> Immix Gc</a></li><li class="chapter-item expanded "><a href="../systemlib/stackmap.html"><strong aria-hidden="true">7.1.1.2.</strong> Stack Map</a></li><li class="chapter-item expanded "><a href="../systemlib/eva.html"><strong aria-hidden="true">7.1.1.3.</strong> Evacuation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../systemlib/planglib.html"><strong aria-hidden="true">7.2.</strong> planglib</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">CONTRIBUTING</li><li class="chapter-item expanded "><a href="../CONTRIBUTING-CN.html"><strong aria-hidden="true">8.</strong> Contributing</a></li><li class="chapter-item expanded affix "><li class="part-title">Blogs</li><li class="chapter-item expanded "><a href="../blogs/aboutpl.html"><strong aria-hidden="true">9.</strong> About pivot lang</a></li><li class="chapter-item expanded "><a href="../blogs/lsp_and_salsa.html"><strong aria-hidden="true">10.</strong> lsp and salsa</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pivot Lang</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Pivot-Studio/pivot-lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Pivot-Studio/pivot-lang/edit/master/book/src/systemlib/immix.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pivot-lang-immix-gc"><a class="header" href="#pivot-lang-immix-gc">pivot-lang immix gc</a></h1>
<p>本文档将会描述pl使用的immix gc的一些实现细节与对外接口</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>此页面仍在编写中，内容可能有疏漏</p>
</div>
</div>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#general-description">General Description</a></li>
<li><a href="#allocation">Allocation</a>
<ul>
<li><a href="#global-allocator">Global Allocator</a></li>
<li><a href="#thread-local-allocator">Thread Local Allocator</a></li>
</ul>
</li>
<li><a href="#mark">Mark</a></li>
<li><a href="#sweep">Sweep</a>
<ul>
<li><a href="#%E5%9B%9E%E6%94%B6block">回收block</a></li>
<li><a href="#%E4%BF%AE%E6%AD%A3line-header">修正line header</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97evacuation%E4%BF%A1%E6%81%AF">计算evacuation信息</a></li>
</ul>
</li>
<li><a href="#evacuation">Evacuation</a></li>
<li><a href="#%E6%80%A7%E8%83%BD">性能</a></li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>此gc是我们基于<a href="https://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf">immix gc论文</a>实现的，
大部分的实现细节都与论文一致，对于一些论文没提到的细节我们自行进行了实现，参考了很多别的gc项目。该gc是一个支持多线程使用的、
基于shadow stack的，精确mark-region 非并发（Concurrency） 并行（Parallelism） gc。</p>
<div id="admonition-gc的并发concurrency与并行parallelism" class="admonition tip">
<div class="admonition-title">
<p>gc的并发（Concurrency）与并行（Parallelism）</p>
<p><a class="admonition-anchor-link" href="#admonition-gc的并发concurrency与并行parallelism"></a></p>
</div>
<div>
<p>gc中并发和并行是两个不同的术语，并发gc指的是能够在应用不暂停的基础上进行回收的gc，
而并行gc指的是gc在回收的时候能够使用多个线程同时进行工作。一个gc可以既是并行的也是并发的，
我们的immix gc目前只具备并行能力</p>
</div>
</div>
这里有一些创建该gc过程中我们主要参考的资料，列表如下：  
<ul>
<li><a href="https://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf">immix gc论文</a></li>
<li><a href="https://github.com/playXE/libimmixcons">playxe 的 immixcons（immix gc的一个rust实现，回收存在bug）-- 很多底层内存相关代码是参考该gc完成的，还有在函数头中加入自定义遍历函数的做法</a></li>
<li><a href="https://github.com/scala-native/immix">给scala-native使用的一个immix gc的C实现</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/immix/">康奈尔大学CS6120课程关于immix gc的博客，可以帮助快速理解论文的基本思路</a></li>
</ul>
<h2 id="general-description"><a class="header" href="#general-description">General Description</a></h2>
<p>本gc是为pl <strong>定制的</strong>，虽然理论上能被其他项目使用，但是对外部项目的支持<strong>并不是主要目标</strong></p>
<p>pl的组件包含一个全局的<code>GlobalAllocator</code>，然后每个<code>mutator</code>线程会包含一个独属于该线程的<code>Collector</code>，每个<code>Collector</code>中包含一个
<code>ThreadLocalAllocator</code>。在线程使用gc相关功能的时候，该线程对应的<code>Collector</code>会自动被创建，直到线程结束或者
用户手动调用销毁api。</p>
<div id="admonition-部分immix-gc术语介绍" class="admonition tip">
<div class="admonition-title">
<p>部分immix gc术语介绍</p>
<p><a class="admonition-anchor-link" href="#admonition-部分immix-gc术语介绍"></a></p>
</div>
<div>
<p><strong>mutator</strong></p>
<p>mutator指使用gc的用户程序，在有些文档里也被指代为gc的client</p>
<p><strong>block</strong></p>
<p>block是immix中全局分配器分配的基础单位，每个block的大小为32KB</p>
<p><strong>line</strong></p>
<p>line是block中的基本单位，每个line长度为128B，每个block中包含256个line</p>
<p><strong>Global Allocator</strong></p>
<p>全局分配器，简称GA，分配内存以block为单位</p>
<p><strong>Thread Local Allocator</strong></p>
<p>线程本地分配器，简称TLA，分配内存以line为单位，在自身的block中分配，如果没有可用的block，会向全局分配器申请</p>
<p><strong>Collector</strong></p>
<p>线程本地的回收器，在每次gc开始的时候会运行标记和驱逐算法，然后通知Thread Local Allocator进行清扫</p>
<p><strong>Evacuation</strong></p>
<p>驱逐算法，是一种反碎片化机制</p>
</div>
</div>
<p>下方是使用immix gc的应用程序的工作流程图：</p>
<pre class="mermaid">graph LR;
    subgraph Program
        style Collector1 fill:#b4b2e6
        style Collector2 fill:#b4b2e6
        direction TB
        subgraph Immix GC
            direction TB
            GA
            Collector1
            Collector2
        end
        GA[Global Allocator]--give blocks--&gt;TLA1;
        TLA1-.return free blocks.-&gt;GA;
        subgraph Collector1
            direction TB
            TLA1[Thread Local Alloctor]
            Marker1[Marker]
        end
        GA--give blocks--&gt;TLA2;
        TLA2-.return free blocks.-&gt;GA;
        subgraph Collector2
            direction TB
            TLA2[Thread Local Alloctor]
            Marker2[Marker]
        end
        subgraph Mutator
            direction TB
            Thread1
            Thread2
        end
        TLA1--lines--&gt;Thread1
        TLA2--lines--&gt;Thread2
        Marker1-.Mark, evacuate.-&gt;TLA1
        Marker2-.Mark, evacuate.-&gt;TLA2
    end

</pre>
<p>Immix GC由于分配以line为单位，在内存利用率上稍有不足，但是其算法保证了极其优秀的内存局部性，配合TLA、GA的设计也大大
减少了线程间的竞争。</p>
<h2 id="allocation"><a class="header" href="#allocation">Allocation</a></h2>
<h3 id="global-allocator"><a class="header" href="#global-allocator">Global Allocator</a></h3>
<p>GA是全局的，一个应用程序中只会有一个，负责分配block。在GA被初始化的时候，会向操作系统申请一大
块连续的内存，然后将其切分为block，每个block的大小为32KB。GA有一个<code>current</code>指针，指向
目前GA分配到的位置。当GA需要分配新block的时候，GA会返回当前<code>current</code>指针指向的内存空间，
并且将<code>current</code>指针向后移动一个block的距离。</p>
<p>GA同时维护一个<code>free</code>动态数组，用于存储已经被回收的block，当GA需要分配新block的时候，会先从<code>free</code>数组中
尝试取出一个block，如果<code>free</code>数组为空，才会分配新的block。</p>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="#admonition-info"></a></p>
</div>
<div>
<p>潜在的优化点：使用bitmap来记录block的使用情况，这样可以减少动态数组的开销</p>
</div>
</div>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="#admonition-warning"></a></p>
</div>
<div>
<p>如果GA在分配新block的时候，发现<code>current</code>指针已经超出了初始申请的内存空间，会导致程序panic。这个行为应该在未来被改善</p>
</div>
</div>
<h3 id="thread-local-allocator"><a class="header" href="#thread-local-allocator">Thread Local Allocator</a></h3>
<p>TLA是线程本地的，每个线程都会有一个TLA，负责分配line，和进行sweep回收。</p>
<div id="admonition-部分tla用到的术语介绍" class="admonition tip">
<div class="admonition-title">
<p>部分TLA用到的术语介绍</p>
<p><a class="admonition-anchor-link" href="#admonition-部分tla用到的术语介绍"></a></p>
</div>
<div>
<ul>
<li>小对象：小于line size的对象</li>
<li>中对象：大于line size，小于block size/4（8KB）的对象</li>
<li>大对象：大于block size/4的对象</li>
<li>hole：block中一个未被使用的连续空间称之为hole</li>
</ul>
</div>
</div>
<p>在每次回收的时候，TLA会将所有完全空闲的block回收给GA，所有部分空闲的block会被加入到<code>recycle</code>数组中，在之后的分配里被重复利用。
所有完全被占用的block会被加入到<code>unavailable</code>数组中，不会被重复利用。</p>
<p>TLA的小对象分配策略如下：</p>
<center>
<pre class="mermaid">graph TD;
    A[分配内存]--&gt;B{有recycle block?}
    B--是--&gt;C[从recycle block中分配line]
    B--否--&gt;D{申请新block}
    D--成功--&gt;E[新block加入recycle block]
    D--失败--&gt;I[panic]
    E--&gt;C
    C--&gt;F{block用完?}
    F--是--&gt;G[移入unavailable block]
    F--否--&gt;H[返回分配空间的指针]
    G--&gt;H
</pre>
</center>
<div id="admonition-中对象大对象分配策略" class="admonition note">
<div class="admonition-title">
<p>中对象、大对象分配策略</p>
<p><a class="admonition-anchor-link" href="#admonition-中对象大对象分配策略"></a></p>
</div>
<div>
<p>中对象存在一个问题，就是如果他采用小对象的分配策略，在recycle block中分配line，那么分配过程中可能跳过
很多的小hole，而TLA的分配器在recycle block中分配的时候是<strong>不回头</strong>的，这样可能会导致：</p>
<ul>
<li>内存碎片增加</li>
<li>分配时间变长</li>
</ul>
<p>因此，中对象分配的时候只会找recycle block中的第一个hole，如果这个hole装不下它，TLA会直接申请新的block来分配该对象，
并且将这个block加入到recycle block中。</p>
<p>大对象分配不使用mark region算法，它使用特殊的bigobject allocator来分配，是传统的mark free算法。</p>
<p>因为程序中小对象的数量远远大于中对象和大对象，所以TLA的分配器会优先优化小对象分配，以增加性能</p>
</div>
</div>
<h2 id="mark"><a class="header" href="#mark">Mark</a></h2>
<p>Mark阶段的主要工作是标记所有被使用的line和block，以便在后续的sweep阶段进行回收。我们的mark算法是<strong>精确</strong>的，
这点对evacuation算法的实现至关重要。</p>
<p>精确GC有两个要求：</p>
<ul>
<li>root的精确定位</li>
<li>对象的精确遍历</li>
</ul>
<p>我们的精确root定位是基于<strong>Stack Map</strong>的，这部分细节过于复杂，将在<a href="stackmap.html">单独的文档</a>中介绍。</p>
<p>对象的精确遍历是通过编译器支持实现的，plimmix将所有heap对象分类为以下4种：</p>
<ul>
<li>Atomic Object：原子对象，不包含指针的对象，如整数、浮点数、字符串等</li>
<li>Pointer Object：指针对象，该对象本身是一个指针</li>
<li>Complex Object：复杂对象，该对象可能包含指针</li>
<li>Trait Object：Trait对象，该对象包含一个指针，在他的offset为8的位置，这个类型是专门配合pivot lang的trait设计的，是个特殊优化</li>
</ul>
<p>对于Atomic Object，我们不需要遍历，因为他们不包含指针。</p>
<p>对于Pointer Object，我们只需要遍历他们的指针即可。</p>
<p>对于Complex Object，编译器需要在对象开始位置增加一个<code>vtable</code>字段，该字段的值指向该类型的遍历函数。此遍历函数由编译器生成，
其签名为：</p>
<pre><code class="language-rust ignore">pub type VisitFunc = unsafe fn(&amp;Collector, *mut u8);
// vtable的签名，第一个函数是mark_ptr，第二个函数是mark_complex，第三个函数是mark_trait
pub type VtableFunc = fn(*mut u8, &amp;Collector, VisitFunc, VisitFunc, VisitFunc);</code></pre>
<p>在标记的时候，我们会调用对象的vtable对他进行遍历</p>
<p>对于Trait Object，我们需要遍历他指向实际值的指针</p>
<p>下方是一个immix heap的示意图，其中<code>*</code>表示该对象会在mark阶段中被标记</p>
<pre class="mermaid">graph LR;
    subgraph Stack
        Root1
        Root2
        Root3
        Root4
    end
    subgraph HO[Heap]
        AtomicObject1[AtomicObject1*]
        AtomicObject2[AtomicObject2*]
        AtomicObject3
        PointerObject1[PointerObject1*]
        PointerObject2[PointerObject2*]
        ComplexObject1
    end
    subgraph ComplexObject1[ComplexObject1*]
        VT1[VTable]
        PF1[PointerField]
        AF1[AtomicField]
        ComplexField
    end
    subgraph ComplexField
        VT2[VTable]
        AF2[AtomicField]
        PF2[PointerField]
    end
    PF1 --&gt; PointerObject1
    PF2 --&gt; AtomicObject2
    PointerObject1 --&gt; AtomicObject1
    PointerObject2 --&gt; ComplexObject1
    Root1 --&gt; PointerObject1
    Root2 --&gt; PointerObject2
    Root3 --&gt; PointerObject1

</pre>
<p>对于<code>ComplexObject1</code>，他的vtable函数逻辑如下：</p>
<pre><code class="language-rust ignore">fn vtable_complex_obj1(&amp;self, mark_ptr: VisitFunc, mark_complex: VisitFunc, mark_trait: VisitFunc){
    mark_ptr(self.PointerField)
    mark_complex(self.ComplexField)
}</code></pre>
<p>而对于<code>ComplexField</code>，他的vtable函数逻辑如下：</p>
<pre><code class="language-rust ignore">fn vtable_complex_field(&amp;self, mark_ptr: VisitFunc, mark_complex: VisitFunc, mark_trait: VisitFunc){
    mark_ptr(self.PointerField)
}</code></pre>
<p>实际上，<code>mark_complex</code>和<code>mark_trait</code>逻辑都十分简单：<code>mark_complex</code>只是调用对象的vtable函数，而
<code>mark_trait</code>只是对实际指针调用<code>mark_ptr</code>，真正的标记和驱逐逻辑都在<code>mark_ptr</code>中实现。</p>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="#admonition-tip"></a></p>
</div>
<div>
<p>标记过程开始的时候，gc会load所有root指向的值，对他们调用<code>mark_ptr</code>，如果该值为gc堆中的对象，
则会将该对象标记，并且再次load它指向的对象，若该对象非AtomicObject类型则加入到mark queue中。</p>
<p>在mark queue中的对象，会被逐个取出，根据他们的类型对他们调用<code>mark_ptr</code>、<code>mark_complex</code>或者<code>mark_trait</code>，直到
mark queue为空，则标记过程结束。</p>
<p>尽管这的确可以看作是一个递归的过程，但是此过程一定不能使用递归的方式实现，因为递归的方式在复杂程序中可能会导致栈溢出。</p>
</div>
</div>
<h2 id="sweep"><a class="header" href="#sweep">Sweep</a></h2>
<p>Sweep阶段的主要工作是：</p>
<ul>
<li>回收所有未被标记的block</li>
<li>修正所有line的header</li>
<li>计算evacuation需要的一些信息</li>
</ul>
<h3 id="回收block"><a class="header" href="#回收block">回收block</a></h3>
<p>回收block的过程非常简单，我们只需要遍历所有的block，如果block的header中的<code>mark</code>字段为<code>false</code>，则将该block回收，统一返回给GA</p>
<h3 id="修正line-header"><a class="header" href="#修正line-header">修正line header</a></h3>
<p>如果一个block被mark了，那么需要对block中的所有lineheader根据line是否被标记
进行修正。</p>
<h3 id="计算evacuation信息"><a class="header" href="#计算evacuation信息">计算evacuation信息</a></h3>
<p>计算一个<code>mark</code>数组，该数组中下标为idx的元素值表示hole数量为idx的所有block的marked line的数量</p>
<h2 id="evacuation"><a class="header" href="#evacuation">Evacuation</a></h2>
<p>每次回收开始之前，我们会先判断是否需要进行反碎片化，目前的策略是只要recycle block&gt;1就进行反碎片化。</p>
<div id="admonition-info-1" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="#admonition-info-1"></a></p>
</div>
<div>
<p>优化点：如果处于内存用尽的紧急情况也应当进行evacuation，且threshold应当设置的更低</p>
</div>
</div>
<p>如果决定了需要进行反碎片化，那么我们会构建一个<code>available</code>数组，该数组中下标为idx的元素值表示hole数量为idx的所有block的可用line的数量，
然后我们按照洞的数量从大到小遍历<code>available</code>和<code>mark</code>数组，会定义一个<code>required</code>值，该值在每次遍历的时候加上<code>mark</code>数组中的值，
减去<code>available</code>数组中的值，如果某次循环后<code>required</code>值小于0，那么当前循环对应的hole数量+1就是我们evacuate的阈值（threshold）。
在此之后根据<code>threshole</code>将所有洞数量大于等于<code>threshole</code>的block标记为待evacuate。</p>
<p>真正的evacuation过程是在<code>mark</code>阶段一起完成的，我们会在遍历到处于待evacuate的block中的对象时，为它分配一个新的地址，并且
将它原地址的值替换为一个指向新地址的指针（forward pointer），且将line header中的<code>forward</code>字段设置为<code>true</code>。之后如果再次遍历到
该对象，收集器会修正指向原地址的指针的值，这一过程我们称之为自愈。该过程如下图所示</p>
<pre class="mermaid">graph TD;
    subgraph BeforeEva
        direction TB
        EvaBlock
        EmptyBlock
        Pointer
    end
    subgraph EvaBlock
        Line1
        Line2
        LineK[...]
        LineN
    end
    subgraph Line1
        Addr[addr: 0x1000]
        Value[value: 0x4321]
        Forward[forward: false]
    end
    subgraph EmptyBlock
        EL1
        ELK[...]
    end
    subgraph EL1[Line1]
        AddrEL[addr: 0x2000]
        ValueEL[value: 0x0000]
    end
    Pointer
    Pointer--&gt;Line1
    subgraph AfterEva
        direction TB
        EvaBlock1
        EmptyBlock1
        Pointer1[Pointer]
    end
    subgraph EvaBlock1[EvaBlock]
        Line11
        Line21[Line2]
        LineK1[...]
        LineN1[LineN]
    end
    subgraph Line11[Line1]
        Addr1[addr: 0x1000]
        Value1[value: 0x2000]
        Forward1[forward: true]
    end
    subgraph EmptyBlock1[EmptyBlock]
        EL11
        ELK1[...]
    end
    subgraph EL11[Line1]
        AddrEL1[addr: 0x2000]
        ValueEL1[value: 0x4321]
    end
    Pointer1--&gt;EL11
    BeforeEva--&gt;AfterEva

</pre>
<p>每次驱逐是以分配的对象为单位，如果一个block被标记为待evacuate，那么在驱逐过程中，该block中的所有对象都一定会被驱逐。</p>
<p>请注意，一部分其他gc的驱逐算法中的自愈需要读写屏障的参与，immix不需要。这带来了较大的mutator性能提升。</p>
<div id="admonition-warning-1" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="#admonition-warning-1"></a></p>
</div>
<div>
<p>驱逐算法的正确性建立在我们的root定位和对象遍历的正确性之上，如果root定位和对象遍历不精确，
建议禁用驱逐算法。这二者的不精确会导致驱逐算法修改的指针不能完全自愈。考虑下方场景：</p>
<pre>
<code class="language-rust ignore hljs">
struct Node {
    next: *mut Node,
    data: u32,
}

fn main() {
    let mut root = Node {
        next: null_mut(),
        data: 0,
    };
    let stack_ptr = &mut root as * mut u8;
    add_root(stack_ptr);
}

fn add_sub_ndoe(root: *mut Node) {
    let mut node = Node {
        next: null_mut(),
        data: 0,
    };
    root.next = &mut node;
}</code>
</pre>
<p>在这个例子中，我们只添加了一个root即<code>main</code>中的<code>root</code>变量，尽管<code>add_sub_node</code>中的<code>node</code>变量和<code>root</code>参数也是root，
但是不添加它们其实不会影响大部分gc在这个例子中的正确性。然而如果启用了驱逐算法，这个例子就很可能在运行时出错。
假如<code>add_sub_node</code>函数中触发了gc，且gc决定进行驱逐，将<code>main</code>函数中的<code>root</code>变量移动到了新的地址，那么在gc过程中
<code>stackptr</code>对应的指针指向的位置会自愈，更改为移动后的地址，但是<code>add_sub_node</code>函数中的<code>root</code>参数因为没被添加到root set中，
这导致gc无法在回收过程中对其进行修正，就会进一步导致<code>root.next</code>指向的地址不正确，从而导致程序出错。</p>
</div>
</div>
<div id="admonition-多线程情况下驱逐算法的安全性" class="admonition tip">
<div class="admonition-title">
<p>多线程情况下驱逐算法的安全性</p>
<p><a class="admonition-anchor-link" href="#admonition-多线程情况下驱逐算法的安全性"></a></p>
</div>
<div>
<p>在多线程情况下，是存在两个线程同时驱逐一个对象的可能的，在这种情况下一些同步操作必不可少，但是并不需要加锁。
我们通过一个cas操作来保证只有一个线程能够成功驱逐该对象。</p>
</div>
</div>
<h2 id="性能"><a class="header" href="#性能">性能</a></h2>
<p>我们与bdwgc进行了很多比较，数据证明在大多数情况下，我们的分配算法略慢于bdwgc，与malloc速度相当，但是在回收的时候，我们的回收速度要快于bdwgc。
对于一些复杂的测试，在触发回收的策略相同的情况下，我们的单线程总执行时间略慢于bdwgc，但是在多线程情况下，我们的总执行时间明显快于bdwgc，
整体来说机器并行能力越强、测试时使用内存越多immix性能优势越大。</p>
<p>使用github action进行的基准测试结果可以在<a href="https://chronostasys.github.io/bdwgcvsimmix-bench/report/">这里</a>查看，由于github action使用的机器
只有两个核心，所以测试线程数量为2，在此结果中，可以看到immix整体性能略差于bdwgc，但是差距小于单线程情况。</p>
<p>你可以从<a href="https://github.com/Chronostasys/bdwgcvsimmix-bench">这里</a>下载测试代码，在你的机器上运行并进行比较。这里我提供一组笔者机器上的测试数据截图</p>
<p><img src="immix.png" alt="" /></p>
<p><img src="bdw.png" alt="" /></p>
<p>测试环境为MacBook Pro (16-inch, 2021) Apple M1 Pro 16 GB，可以看出immix在此环境中已经具有近4倍的性能优势。</p>
<p>immix作为天生并发的gc，并发情况下几乎能完全避免锁竞争的出现，因此在多线程情况下的性能优势是非常明显的。并且其分配算法很好的维护了空间局部性，理论上
能带来更好的mutator性能。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../systemlib/gc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../systemlib/stackmap.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../systemlib/gc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../systemlib/stackmap.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </body>
</html>
